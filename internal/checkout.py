from . import util
from . import loaders
from . import config
from . import backend
from . import reset
class Task:
    def __init__(self):
        self.proj = None
        self.buggy = None
        self.bug_id = None
        self.cid = None
        self.working_dir = None
        self.loader = None
INVALID = -1
COMMON = 0
D4J = 1
def print_help():
    util.printc('usage: catena4j checkout -p project_name -v bug_id[*b[*], *f[*]] -w working_dir')
def is_number(n):
    for i in n:
        if not ('0' <= i and '9' >= i):
            return False
    return True
def tokenize(v):
    if v.endswith('b'):
        return v[:-1], True, None
    elif v.endswith('f'):
        return v[:-1], False, None
    else:
        buggy = 'b' in v
        ch = 'b'
        if not buggy:
            assert 'f' in v
            ch = 'f'
        return v[:v.find(ch)], buggy, v[v.find(ch) + 1:]
def sanity_check(task):
    registry = open('{}/projects/{}/bugs-registry.csv'.format(config.root, task.proj), 'r').read().splitlines()[1:]
    for line in registry:
        line = line.split(',')
        if task.bug_id == line[0].strip() and task.cid == line[1].strip():
            task.loader = loaders.get_loader(line[2].strip())
            return True
    util.printc('Cannot find cid in bugs-registry')
    return False
def validate(args):
    if not util.exists('{}/projects/{}'.format(config.root, args.p)):
        return D4J, None
    if not args.o == None:
        util.printc('Unknown parameter: -o')
        return INVALID, None
    if args.w == None or args.v == None or args.p == None:
        util.printc('Incompleted parameters')
        return INVALID, None
    if not 'b' in args.v and not 'f' in args.v:
        util.printc('Incompleted version parameter for -v')
        return INVALID, None
    bid, bg, cid = tokenize(args.v)
    if cid == None:
        return D4J, None
    if not is_number(bid) or not is_number(cid):
        util.printc('Invalid no number bug_id or cid')
        return INVALID, None
    task = Task()
    task.proj = args.p
    task.bug_id = bid
    task.working_dir = args.w
    task.buggy = bg
    task.cid = cid
    if not sanity_check(task):
        return INVALID, None
    return COMMON, task
def generate_c4j_info(task, p):
    info = '# this file is automatically generated\n'
    info += 'project={}\n'.format(task.proj)
    info += 'bugid={}\n'.format(task.bug_id)
    info += 'cid={}\n'.format(task.cid)
    info += 'vtag={}\n'.format('b' if task.buggy else 'f')
    util.printc('Trying to commit changes')
    util.system('cd {} && git add .'.format(p))
    #util.system('cd {} && git commit -m "catena4j"'.format(p))
    ret = util.run_and_get(['git', 'commit', '-m', '"catena4j"'], at=p)
    if not ret[0]:
        util.printc('Command git commit returns non-zero (may be nothing to commit)')
    if ret[1].strip():
        util.printc(ret[1], head='')
    commit_id = util.run_and_get(['git', 'rev-parse', 'HEAD'], at=p)
    if not commit_id[0]:
        util.printc(commit_id[1])
        util.printc('Failed to capture commit id, see error info.')
    else:
        info += 'commit={}\n'.format(commit_id[1])
        util.printc('Commit id: {}'.format(commit_id[1]))
    with open('{}/.catena4j.info'.format(p), 'w') as w:
        w.write(info)
    util.printc('Info file generated.')
def checkout_internal(task):
    task.loader.load(task.proj, task.bug_id, task.cid, task.buggy, task.working_dir)
    generate_c4j_info(task, task.working_dir)
__RESET_NOT_IMPLEMENTED__ = 1
__FALSE = 0
__RESET = 1
__RESET_AND_FIX = 2
__RESET_AND_LOAD = 3
def test_line_match(line, want):
    return line.split('=')[1].strip() == want
def should_trap_d4j(task):
    if not util.exists(f'{task.working_dir}/.defects4j.config'):
        return __FALSE
    with open(f'{task.working_dir}/.defects4j.config', 'r') as f:
        info = f.read().splitlines()
    bid = ''
    for line in info:
        if 'pid' in line:
            if not test_line_match(line, task.proj):
                return __FALSE
        if 'bid' in line:
            bid = line.split('=')[1].strip()
    if not bid[:-1] == task.bug_id:
        return __FALSE
    if bid.endswith('f'):
        return __FALSE
    if __RESET_NOT_IMPLEMENTED__:
        util.printc('reset command is not implemented, use default checkout')
        return __FALSE
    # bid endswith 'b' in this case
    return __RESET_AND_LOAD
def should_trap(task):
    if not util.exists(f'{task.working_dir}/.catena4j.info'):
        return should_trap_d4j(task)
    with open(f'{task.working_dir}/.catena4j.info', 'r') as f:
        info = f.read().splitlines()
    ver_tag = ''
    for line in info:
        if 'project' in line:
            if not test_line_match(line, task.proj):
                return __FALSE
        elif 'bugid' in line:
            if not test_line_match(line, task.bug_id):
                return __FALSE
        elif 'cid' in line:
            if not test_line_match(line, task.cid):
                return __FALSE
        elif 'vtag' in line:
            ver_tag = line.split('=')[1].strip()
    if ver_tag == 'f' and task.buggy:
        return __FALSE
    if __RESET_NOT_IMPLEMENTED__:
        util.printc('reset command is not implemented, use default checkout')
        return __FALSE
    if ver_tag == 'b' and not task.buggy:
        return __RESET_AND_FIX
    return __RESET
def try_to_reset(task):
    level = should_trap(task)
    if level > __FALSE:
        reset.reset_internal(task.wd)
        if level == __RESET_AND_FIX:
            task.loader.fix(task.proj, task.bug_id, task.cid, task.working_dir)
            return 0
        if level == __RESET_AND_LOAD:
            return 1
        return 0
    return 1
def CHECKOUT(args):
    stat, task = validate(args)
    if stat == INVALID:
        print_help()
    if stat == D4J:
        backend.d4j_backend()
    if stat == COMMON:
        if try_to_reset(task):
            checkout_internal(task)
        util.task_printc('Tasks all done').finish()
