from . import util
from . import loaders
from . import config
from . import backend
from . import reset
class Task:
    def __init__(self):
        self.proj = None
        self.buggy = None
        self.bug_id = None
        self.cid = None
        self.working_dir = None
        self.loader = None
INVALID = -1
COMMON = 0
D4J = 1
def print_help():
    util.printc('usage: catena4j checkout -p project_name -v bug_id[*b[*], *f[*]] -w working_dir')
def is_number(n):
    for i in n:
        if not ('0' <= i and '9' >= i):
            return False
    return True
def tokenize(v):
    if v.endswith('b'):
        return v[:-1], True, None
    elif v.endswith('f'):
        return v[:-1], False, None
    else:
        buggy = 'b' in v
        ch = 'b'
        if not buggy:
            assert 'f' in v
            ch = 'f'
        return v[:v.find(ch)], buggy, v[v.find(ch) + 1:]
def sanity_check(task):
    registry = open('{}/projects/{}/bugs-registry.csv'.format(config.root, task.proj), 'r').read().splitlines()[1:]
    for line in registry:
        line = line.split(',')
        if task.bug_id == line[0].strip() and task.cid == line[1].strip():
            task.loader = loaders.get_loader(line[2].strip())
            return True
    util.printc('Cannot find cid in bugs-registry')
    return False
def validate(args):
    validator = util.args_validator(args, 'wvp', cmd='checkout')
    validator.validate()
    if not validator.is_valid():
        validator.print_all(util.printc)
        return INVALID, None
    if not util.exists('{}/projects/{}'.format(config.root, args.p)):
        return D4J, None
    if not 'b' in args.v and not 'f' in args.v:
        util.printc('Incompleted version parameter for -v')
        return INVALID, None
    bid, bg, cid = tokenize(args.v)
    if cid == None:
        return D4J, None
    if not is_number(bid) or not is_number(cid):
        util.printc('Invalid no number bug_id or cid')
        return INVALID, None
    task = Task()
    task.proj = args.p
    task.bug_id = bid
    task.working_dir = args.w
    task.buggy = bg
    task.cid = cid
    if not sanity_check(task):
        return INVALID, None
    return COMMON, task
def base_c4j_info(task):
    info = '# this file is automatically generated\n'
    info += 'project={}\n'.format(task.proj)
    info += 'bugid={}\n'.format(task.bug_id)
    info += 'cid={}\n'.format(task.cid)
    return info
def generate_c4j_info(task, p):
    info = base_c4j_info(task)
    info += 'vtag={}\n'.format('b' if task.buggy else 'f')
    if util.config_run(config.CONFIG_RESET_IN_CHECKOUT, 0, reset.git_clean, p):
        return -1
    commit_task = util.task_printc('Trying to commit changes')
    util.system('cd {} && git add .'.format(p))
    #util.system('cd {} && git commit -m "catena4j"'.format(p))
    ret = util.run_and_get(['git', 'commit', '-m', '"catena4j"'], at=p)
    if not ret[0]:
        commit_task.fail()
        util.printc('Command git commit returns non-zero (may be nothing to commit)')
        return -1
    commit_task.finish()
    '''
    if ret[1].strip():
        util.printc(ret[1].rstrip(), head='')
    '''
    capture_task = util.task_printc('Capture commit id')
    commit_id = util.run_and_get(['git', 'rev-parse', 'HEAD'], at=p)
    if not commit_id[0]:
        util.printc(commit_id[1])
        util.printc('Failed to capture commit id, see error info.')
        capture_task.fail()
        return -1
    else:
        info += 'commit={}\n'.format(commit_id[1])
        #util.printc('Commit id: {}'.format(commit_id[1].rstrip()))
        capture_task.finish()
    write_task = util.task_printc('Generate info file')
    with open('{}/.catena4j.info'.format(p), 'w') as w:
        w.write(info)
    write_task.finish()
    return 0
def write_c4j_info(task, p, buggy):
    info = base_c4j_info(task)
    v_tag = 'BUGGY' if buggy else 'FIXED'
    info += 'vtag={}\n'.format(v_tag)
    with open('{}/.catena4j.info'.format(p), 'w') as w:
        w.write(info)
    commit_task = util.task_printc(f'Commit {v_tag} version')
    util.system('cd {} && git add .'.format(p))
    ret = util.run_and_get(['git', 'commit', '-m', '{}'.format(util.get_c4j_tag(task.proj, task.bug_id, task.cid, buggy))], at=p)
    if not ret[0]:
        commit_task.fail()
        util.printc('Command git commit returns non-zero (may be nothing to commit)')
        return -1
    commit_task.finish()
    tag_task = util.task_printc(f'Tag {v_tag} version')
    ret = util.run_and_get(['git', 'tag', '{}'.format(util.get_c4j_tag(task.proj, task.bug_id, task.cid, buggy))], at=p)
    if not ret[0]:
        tag_task.fail()
        util.printc('Command git tag returns non-zero')
        return -1
    tag_task.finish()
    return 0
def get_line_attr(line):
    return line.split('=')[1].strip()
def directly_checkout(task):
    if not util.exists(f'{task.working_dir}/.catena4j.info'):
        return False
    with open(f'{task.working_dir}/.catena4j.info', 'r') as f:
        info = f.read().splitlines()
    for line in info:
        if 'project' in line:
            if not get_line_attr(line) == task.proj:
                return False
        if 'bugid' in line:
            if not get_line_attr(line) == task.bug_id:
                return False
        if 'cid' in line:
            if not get_line_attr(line) == task.cid:
                return False
    return True
def checkout_with_tag(task):
    task.loader.load(task.proj, task.bug_id, task.cid, True, task.working_dir)
    write_ret = write_c4j_info(task, task.working_dir, True)
    init_task = util.task_printc('Initialize BUGGY version')
    init_task.fail() if write_ret else init_task.finish()
    task.loader.fix(task.proj, task.bug_id, task.cid, task.working_dir)
    write_ret = write_c4j_info(task, task.working_dir, False)
    init_task = util.task_printc('Initialize FIXED version')
    init_task.fail() if write_ret else init_task.finish()
    return checkout_tag(task)
def checkout_tag(task):
    check_out_task = util.task_printc('Check out {} version'.format('BUGGY' if task.buggy else 'FIXED')) 
    tag = util.get_c4j_tag(task.proj, task.bug_id, task.cid, task.buggy)
    ret = util.run_and_get(['git', 'checkout', tag], at=task.working_dir)
    if not ret[0]:
        check_out_task.fail()
        return -1
    check_out_task.finish()
    if reset.git_clean(task.working_dir):
        return -1
    return 0
def checkout_internal(task):
    task.loader.load(task.proj, task.bug_id, task.cid, task.buggy, task.working_dir)
    return generate_c4j_info(task, task.working_dir)
if config.CONFIG_RESET_IN_CHECKOUT:
    #__RESET_NOT_IMPLEMENTED__ = 1
    __FALSE = 0
    __RESET = 1
    __RESET_AND_FIX = 2
    __RESET_AND_LOAD = 3
    __CLEAN = 4
    def test_line_match(line, want):
        return line.split('=')[1].strip() == want
    def should_trap_d4j(task):
        if not util.exists(f'{task.working_dir}/.defects4j.config'):
            return __FALSE
        with open(f'{task.working_dir}/.defects4j.config', 'r') as f:
            info = f.read().splitlines()
        bid = ''
        for line in info:
            if 'pid' in line:
                if not test_line_match(line, task.proj):
                    return __FALSE
            if 'bid' in line:
                bid = line.split('=')[1].strip()
        if not bid[:-1] == task.bug_id:
            return __FALSE
        if bid.endswith('f'):
            return __FALSE
        '''
        if __RESET_NOT_IMPLEMENTED__:
            util.printc('reset command is not implemented, use default checkout')
            return __FALSE
        '''
        # bid endswith 'b' in this case
        return __RESET_AND_LOAD
    def should_trap(task):
        if not util.exists(f'{task.working_dir}/.catena4j.info'):
            return should_trap_d4j(task)
        with open(f'{task.working_dir}/.catena4j.info', 'r') as f:
            info = f.read().splitlines()
        ver_tag = ''
        for line in info:
            if 'project' in line:
                if not test_line_match(line, task.proj):
                    return __FALSE
            elif 'bugid' in line:
                if not test_line_match(line, task.bug_id):
                    return __FALSE
            elif 'cid' in line:
                if not test_line_match(line, task.cid):
                    return __FALSE
            elif 'vtag' in line:
                ver_tag = line.split('=')[1].strip()
        if ver_tag == 'f' and task.buggy:
            return __FALSE
        '''
        if __RESET_NOT_IMPLEMENTED__:
            util.printc('reset command is not implemented, use default checkout')
            return __FALSE
        '''
        if ver_tag == 'b' and not task.buggy:
            return __RESET_AND_FIX
        return __RESET
    def try_to_reset(task):
        level = should_trap(task)
        if level > __FALSE:
            reset.reset_internal(task.working_dir)
            if level == __RESET_AND_FIX:
                task.loader.fix(task.proj, task.bug_id, task.cid, task.working_dir)
                return generate_c4j_info(task, task.working_dir)
            if level == __RESET_AND_LOAD:
                return 1
            return 0
        return 1
else:
    def try_to_reset(task):
        return 1
def CHECKOUT(args):
    stat, task = validate(args)
    if stat == INVALID:
        print_help()
    if stat == D4J:
        backend.d4j_backend()
    if stat == COMMON:
        if config.CONFIG_GIT_TAG:
            ret_v = checkout_tag(task) if directly_checkout(task) else checkout_with_tag(task)
        else:
            ret_v = try_to_reset(task)
            if ret_v > 0:
                ret_v = checkout_internal(task)
        done_task = util.task_printc('Tasks all done')
        if ret_v:
            done_task.fail()
        else:
            done_task.finish()
