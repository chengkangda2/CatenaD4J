{
    "com.google.javascript.jscomp.CodePrinterTest::testPrint": {
        "begin_line_no": 166,
        "end_line_no": 370,
        "file_path": "test/com/google/javascript/jscomp/CodePrinterTest.java",
        "to": [
            "  public void testPrint$catena_16() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_0() {\n    assertPrint(\"10 + a + b\", \"10+a+b\");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_1() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_2() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_3() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_4() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_5() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_6() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"a instanceof b\", \"a instanceof b\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_7() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"typeof(a)\", \"typeof a\");                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_8() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_9() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_10() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_11() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_12() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_13() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_14() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_15() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_17() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_18() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_19() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_20() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_21() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_22() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_23() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_24() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    assertPrint(\"new A\", \"new A\");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_25() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"new A()\", \"new A\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_26() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_27() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    assertPrint(\"new A().a()\", \"(new A).a()\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_28() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(new A).a()\", \"(new A).a()\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_29() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_30() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    assertPrint(\"new A.B\", \"new A.B\");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_31() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"new A.B()\", \"new A.B\");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_32() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_33() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_34() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_35() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                                /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_36() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    assertPrint(\"x + +y\", \"x+ +y\");                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_37() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x - (-y)\", \"x- -y\");                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_38() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x++ +y\", \"x++ +y\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_39() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x-- -y\", \"x-- -y\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_40() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x++ -y\", \"x++-y\");                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_41() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_42() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                                 /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_43() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    assertPrint(\"({})\", \"({})\");                                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_44() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var x = {};\", \"var x={}\");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_45() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({}).x\", \"({}).x\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_46() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_47() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_48() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({}) || 1\", \"({})||1\");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_49() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"1 || ({})\", \"1||{}\");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_50() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_51() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_52() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_53() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"typeof ({})\", \"typeof{}\");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_54() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"f({})\", \"f({})\");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_55() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    assertPrint(\"(function(){})\", \"(function(){})\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_56() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(function(){})()\", \"(function(){})()\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_57() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_58() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_59() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                           /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_60() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_61() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_62() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    assertPrint(\"(function f(){})\", \"(function f(){})\");                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_63() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    assertPrint(\"function f(){}\", \"function f(){}\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_64() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_65() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                       /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_66() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_67() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_68() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_69() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_70() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_71() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_72() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                            /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_73() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_74() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_75() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_76() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_77() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_78() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                            /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_79() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    assertPrint(\"! ! true\", \"!!true\");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_80() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"!(!(true))\", \"!!true\");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_81() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_82() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_83() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                                   /***** ORIGINAL ASSERTION IS HERE *****/ // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_84() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    assertPrint(\"+(--x)\", \"+--x\");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_85() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"-(++x)\", \"-++x\");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_86() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    assertPrint(\"-(--x)\", \"- --x\");                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_87() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"!(~~5)\", \"!~~5\");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_88() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_89() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_90() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_91() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_92() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_93() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_94() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_95() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                                /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_96() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    assertPrint(\"a,b,c\", \"a,b,c\");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_97() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"(a,b),c\", \"a,b,c\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_98() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_99() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_100() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_101() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_102() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_103() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_104() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_105() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_106() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_107() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_108() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_109() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_110() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_111() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_112() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_113() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_114() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_115() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_116() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_117() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_118() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    assertPrint(\"if (x){}\", \"if(x);\");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_119() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"if(x);\", \"if(x);\");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_120() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_121() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_122() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testPrint$catena_123() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                      /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
        ]
    },
    "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity": {
        "begin_line_no": 458,
        "end_line_no": 462,
        "file_path": "test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java",
        "to": [
            "  public void testAssocitivity$catena_1() {\n    try{ test(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c; (a || b) || c; (a * b) * c; (a | b) | c\");                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    testSame(\"var a,b,c; a % (b % c); a / (b / c); a - (b - c);\");                                          /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
        ]
    }
}