{
    "com.google.javascript.jscomp.CodePrinterTest::testPrint": {
        "begin_line_no": 166,
        "end_line_no": 370,
        "file_path": "test/com/google/javascript/jscomp/CodePrinterTest.java",
        "to": [
            "  public void testPrint$catena_16() {\n    try{ assertPrint(\"10 + a + b\", \"10+a+b\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"10 + (30*50)\", \"10+30*50\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"with(x) { x + 3; }\", \"with(x)x+3\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa'a\\\"\", \"\\\"aa'a\\\"\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\"aa\\\\\\\"a\\\"\", \"'aa\\\"a'\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function foo()\\n{return 10;}\", \"function foo(){return 10}\");                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a instanceof b\", \"a instanceof b\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(a)\", \"typeof a\");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\n        \"var foo = x ? { a : 1 } : {a: 3, b:4, \\\"default\\\": 5, \\\"foo-bar\\\": 6}\",\n        \"var foo=x?{a:1}:{a:3,b:4,\\\"default\\\":5,\\\"foo-bar\\\":6}\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Safari: needs ';' at the end of a throw statement\n    try{ assertPrint(\"function foo(){throw 'error';}\",\n        \"function foo(){throw\\\"error\\\";}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Safari 3 needs a \"{\" around a single function\n    try{ assertPrint(\"if (true) function foo(){return}\",\n        \"if(true){function foo(){return}}\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"var x = 10; { var y = 20; }\", \"var x=10;var y=20\");                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"while (x-- > 0);\", \"while(x-- >0);\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- >> 1\", \"x-- >>1\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"(function () {})(); \",\n        \"(function(){})()\");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Associativity\n    try{ assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n        \"var a,b,c,d;a||b&&c&&(a||d)\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n        \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Nested assignments\n    try{ assertPrint(\"var a,b; a = b = 3;\",\n        \"var a,b;a=b=3\");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n        \"var a,b,c,d;a=b=c=d=3\");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a += (b = c += 3);\",\n        \"var a,b,c;a+=b=c+=3\");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var a,b,c; a *= (b -= c);\",\n        \"var a,b,c;a*=b-=c\");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Precedence\n    try{ assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(delete a[0])/10\", \"delete a[0]/10\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // optional '()' for new\n\n    // simple new\n    try{ assertPrint(\"new A\", \"new A\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A()\", \"new A\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A('x')\", \"new A(\\\"x\\\")\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new\n    try{ assertPrint(\"new A().a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(new A).a()\", \"(new A).a()\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // this case should be fixed\n    try{ assertPrint(\"new A('y').a()\", \"(new A(\\\"y\\\")).a()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // internal class\n    try{ assertPrint(\"new A.B\", \"new A.B\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B()\", \"new A.B\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B('z')\", \"new A.B(\\\"z\\\")\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // calling instance method directly after new internal class\n    try{ assertPrint(\"(new A.B).a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new A.B().a()\", \"(new A.B).a()\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    // this case should be fixed\n    try{ assertPrint(\"new A.B('w').a()\", \"(new A.B(\\\"w\\\")).a()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Operators: make sure we don't convert binary + and unary + into ++\n    try{ assertPrint(\"x + +y\", \"x+ +y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x - (-y)\", \"x- -y\");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ +y\", \"x++ +y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x-- -y\", \"x-- -y\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x++ -y\", \"x++-y\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Label\n    try{ assertPrint(\"foo:for(;;){break foo;}\", \"foo:for(;;)break foo\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo:while(1){continue foo;}\", \"foo:while(1)continue foo\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Object literals.\n    try{ assertPrint(\"({})\", \"({})\");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = {};\", \"var x={}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}).x\", \"({}).x\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({})['x']\", \"({})[\\\"x\\\"]\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) instanceof Object\", \"({})instanceof Object\");                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) || 1\", \"({})||1\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"1 || ({})\", \"1||{}\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) ? 1 : 2\", \"({})?1:2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? ({}) : 2\", \"0?{}:2\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"0 ? 1 : ({})\", \"0?1:{}\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof ({})\", \"typeof{}\");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f({})\", \"f({})\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Anonymous function expressions.\n    try{ assertPrint(\"(function(){})\", \"(function(){})\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})()\", \"(function(){})()\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){})instanceof Object\",\n        \"(function(){})instanceof Object\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function(){}).bind().call()\",\n        \"(function(){}).bind().call()\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { };\", \"var x=function(){}\");                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x = function() { }();\", \"var x=function(){}()\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(function() {}), 2\", \"(function(){}),2\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Name functions expression.\n    try{ assertPrint(\"(function f(){})\", \"(function f(){})\");                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Function declaration.\n    try{ assertPrint(\"function f(){}\", \"function f(){}\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure we don't treat non-Latin character escapes as raw strings.\n    try{ assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test if statement and for statements with single statements in body.\n    try{ assertPrint(\"if (true) { alert();}\", \"if(true)alert()\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if (false) {} else {alert(\\\"a\\\");}\",\n        \"if(false);else alert(\\\"a\\\")\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"for(;;) { alert();};\", \"for(;;)alert()\");                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertPrint(\"do { alert(); } while(true);\",\n        \"do alert();while(true)\");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: { alert();}\",\n        \"myLabel:alert()\");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"myLabel: for(;;) continue myLabel;\",\n        \"myLabel:for(;;)continue myLabel\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested var statement\n    try{ assertPrint(\"if (true) var x; x = 4;\", \"if(true)var x;x=4\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Non-latin identifier. Make sure we keep them escaped.\n    try{ assertPrint(\"\\\\u00fb\", \"\\\\u00fb\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"\\\\u00fa=1\", \"\\\\u00fa=1\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"function \\\\u00f9(){}\", \"function \\\\u00f9(){}\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x.\\\\u00f8\", \"x.\\\\u00f8\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"abc\\\\u4e00\\\\u4e01jkl\", \"abc\\\\u4e00\\\\u4e01jkl\");                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test the right-associative unary operators for spurious parens\n    try{ assertPrint(\"! ! true\", \"!!true\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(!(true))\", \"!!true\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(0))\", \"typeof void 0\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"typeof(void(!0))\", \"typeof void!0\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"+ - + + - + 3\", \"+-+ +-+3\");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus\n    try{ assertPrint(\"+(--x)\", \"+--x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"-(++x)\", \"-++x\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // needs a space to prevent an ambiguous parse\n    try{ assertPrint(\"-(--x)\", \"- --x\");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"!(~~5)\", \"!~~5\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"~(a/b)\", \"~(a/b)\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Preserve parens to overcome greedy binding of NEW\n    try{ assertPrint(\"new (foo.bar()).factory(baz)\", \"new (foo.bar().factory)(baz)\");                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (bar()).factory(baz)\", \"new (bar().factory)(baz)\");                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"new (new foobar(x)).factory(baz)\",\n        \"new (new foobar(x)).factory(baz)\");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Make sure that HOOK is right associative\n    try{ assertPrint(\"a ? b : (c ? d : e)\", \"a?b:c?d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a ? (b ? c : d) : e\", \"a?b?c:d:e\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a ? b : c) ? d : e\", \"(a?b:c)?d:e\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test nested ifs\n    try{ assertPrint(\"if (x) if (y); else;\", \"if(x)if(y);else;\");                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Test comma.\n    try{ assertPrint(\"a,b,c\", \"a,b,c\");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"(a,b),c\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"a,(b,c)\", \"a,b,c\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,b,c\", \"x=a,b,c\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,b),c\", \"x=(a,b),c\");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,(b,c)\", \"x=a,b,c\");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=a,y=b,z=c\", \"x=a,y=b,z=c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=(a,y=b,z=c)\", \"x=(a,y=b,z=c)\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,b,c,d]\", \"x=[a,b,c,d]\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,b,c),d]\", \"x=[(a,b,c),d]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[(a,(b,c)),d]\", \"x=[(a,b,c),d]\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"x=[a,(b,c,d)]\", \"x=[a,(b,c,d)]\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b)\", \"var x=(a,b)\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b,c\", \"var x=a,b,c\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=(a,b),c\", \"var x=(a,b),c\");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"var x=a,b=(c,d)\", \"var x=a,b=(c,d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo(a,b,c,d)\", \"foo(a,b,c,d)\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,b,c),d)\", \"foo((a,b,c),d)\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"foo((a,(b,c)),d)\", \"foo((a,b,c),d)\");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"f(a+b,(c,d,(e,f,g)))\", \"f(a+b,(c,d,e,f,g))\");                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , 1 , 2\", \"({}),1,2\");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"({}) , {} , {}\", \"({}),{},{}\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // EMPTY nodes\n    try{ assertPrint(\"if (x){}\", \"if(x);\");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x);\", \"if(x);\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x)if(y);\", \"if(x)if(y);\");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n  }"
        ]
    }
}