{
    "com.google.javascript.jscomp.NodeUtilTest::testLocalValue1": {
        "begin_line_no": 1073,
        "end_line_no": 1170,
        "file_path": "test/com/google/javascript/jscomp/NodeUtilTest.java",
        "to": [
            "  public void testLocalValue1$catena_60() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"delete a.b\"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n  }",
            "  public void testLocalValue1$catena_0() throws Exception {\n    // Names are not known to be local.\n    assertFalse(testLocalValue(\"x\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_1() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x()\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_2() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"this\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_3() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"arguments\"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_4() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    assertFalse(testLocalValue(\"new x()\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_5() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    assertFalse(testLocalValue(\"(new x()).y\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_6() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"(new x())['y']\"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_7() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    assertTrue(testLocalValue(\"null\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_8() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"undefined\"));                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_9() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"Infinity\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_10() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"NaN\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_11() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"1\"));                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_12() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"'a'\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_13() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"true\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_14() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"false\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_15() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"[]\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_16() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"{}\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_17() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    assertTrue(testLocalValue(\"[x]\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_18() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"{'a':x}\"));                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_19() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    assertTrue(testLocalValue(\"++x\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_20() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"--x\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_21() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    assertFalse(testLocalValue(\"x++\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_22() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x--\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_23() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    assertTrue(testLocalValue(\"x=1\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_24() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x=[]\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_25() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_26() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    assertTrue(testLocalValue(\"x+=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_27() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x*=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_28() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    assertTrue(testLocalValue(\"x==y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_29() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x!=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_30() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x>y\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_31() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    assertTrue(testLocalValue(\"(1,2)\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_32() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"(x,1)\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_33() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"(x,y)\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_34() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    assertTrue(testLocalValue(\"1||2\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_35() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x||1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_36() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x||y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_37() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"1||y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_38() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    assertTrue(testLocalValue(\"1&&2\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_39() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x&&1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_40() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x&&y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_41() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"1&&y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_42() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    assertTrue(testLocalValue(\"x?1:2\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_43() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?x:2\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_44() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?1:x\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_45() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?x:y\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_46() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    assertTrue(testLocalValue(\"!y\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_47() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"~y\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_48() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y + 1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_49() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y + z\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_50() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y * z\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_51() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"'a' in x\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_52() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"typeof x\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_53() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x instanceof y\"));                                                           /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_54() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"void x\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_55() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"void 0\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_56() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(testLocalValue(\"{}.x\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_57() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"{}.toString()\"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_58() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"o.toString()\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testLocalValue1$catena_59() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }"
        ]
    },
    "com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult": {
        "begin_line_no": 1467,
        "end_line_no": 1517,
        "file_path": "test/com/google/javascript/jscomp/NodeUtilTest.java",
        "to": [
            "  public void testIsBooleanResult$catena_0() {\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_1() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_2() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_3() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_4() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_5() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_6() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_7() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_8() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_9() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_10() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_11() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_12() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_13() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_14() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_15() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_16() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_17() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_18() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_19() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_20() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_21() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_22() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_23() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_24() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_25() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_26() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_27() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_28() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_29() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_30() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_31() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_32() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_34() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_35() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                           /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_36() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_37() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_38() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_39() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_40() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
            "  public void testIsBooleanResult$catena_41() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
        ]
    }
}