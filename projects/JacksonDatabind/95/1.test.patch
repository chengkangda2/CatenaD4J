{
    "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames": {
        "begin_line_no": 209,
        "end_line_no": 250,
        "file_path": "src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java",
        "to": [
            "    public void testCanonicalNames$catena_3()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_1()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_12()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    }",
            "    public void testCanonicalNames$catena_9()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(CollectionType.class, t.getClass());                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_4()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                          /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_5()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_10()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        assertEquals(Object.class, t.getContentType().getRawClass());                                       /***** ORIGINAL ASSERTION IS HERE *****/\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_0()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        assertEquals(\"java.util.Calendar\", can);                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_8()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        assertEquals(List.class, t.getRawClass());                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_2()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                         /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_6()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_7()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(t, tf.constructFromCanonical(can));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.List<java.lang.Object>\", can);                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testCanonicalNames$catena_11()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n        try{ assertEquals(\"java.util.Calendar\", can);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n        try{ assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                can);                                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\");\n        try{ assertEquals(List.class, t.getRawClass());                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(CollectionType.class, t.getClass());                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        // 01-Mar-2018, tatu: not 100% should we expect type parameters here...\n        //    But currently we do NOT get any\n        /*\n        assertEquals(1, t.containedTypeCount());\n        assertEquals(Object.class, t.containedType(0).getRawClass());\n        */\n        try{ assertEquals(Object.class, t.getContentType().getRawClass());                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        can = t.toCanonical();\n        assertEquals(\"java.util.List<java.lang.Object>\", can);                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(t, tf.constructFromCanonical(can));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    }"
        ]
    }
}