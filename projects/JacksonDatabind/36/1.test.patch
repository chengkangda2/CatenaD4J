{
    "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient": {
        "begin_line_no": 19,
        "end_line_no": 57,
        "file_path": "src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java",
        "to": [
            "    public void testLenient$catena_3() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_5() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        assertFalse(f3.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_2() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_1() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        assertTrue(f2.isLenient());                                                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_8() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            verifyException(e, \"can not parse date\");                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_0() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        assertTrue(f.isLenient());                                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_6() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_4() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        assertFalse(f2.isLenient());                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    }",
            "    public void testLenient$catena_9() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n        try{ assertTrue(f.isLenient());                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        StdDateFormat f2 = f.clone();\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        f2.setLenient(true);\n        try{ assertTrue(f2.isLenient());                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // and for testing, finally, leave as non-lenient\n        f2.setLenient(false);\n        try{ assertFalse(f2.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        StdDateFormat f3 = f2.clone();\n        try{ assertFalse(f3.isLenient());                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // first, legal dates are... legal\n        Date dt = f3.parse(\"2015-11-30\");\n        try{ assertNotNull(dt);                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // but as importantly, when not lenient, do not allow\n        try {\n            f3.parse(\"2015-11-32\");\n            try{ fail(\"Should not pass\");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        } catch (ParseException e) {\n            try{ verifyException(e, \"can not parse date\");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n        }\n\n        // ... yet, with lenient, do allow\n        f3.setLenient(true);\n        dt = f3.parse(\"2015-11-32\");\n        assertNotNull(dt);                                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    }"
        ]
    }
}