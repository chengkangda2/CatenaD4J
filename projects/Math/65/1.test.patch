{
    "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest::testCircleFitting": {
        "begin_line_no": 398,
        "end_line_no": 445,
        "file_path": "src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java",
        "to": [
            "    public void testCircleFitting$catena_17() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.004, errors[1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    }",
            "    public void testCircleFitting$catena_16() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        assertEquals(0.004, errors[0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_0() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        assertTrue(optimizer.getEvaluations() < 10);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_1() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertTrue(optimizer.getJacobianEvaluations() < 10);                                                /***** ORIGINAL ASSERTION IS HERE *****/\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_2() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                         /***** ORIGINAL ASSERTION IS HERE *****/\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_3() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                                 /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_4() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(96.07590211815305, center.x,      1.0e-10);                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_5() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(48.13516790438953, center.y,      1.0e-10);                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_6() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        assertEquals(1.839, cov[0][0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_7() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.731, cov[0][1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_8() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_9() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.786, cov[1][1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_10() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        assertEquals(1.384, errors[0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_11() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.905, errors[1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_12() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        assertEquals(0.0016, cov[0][0], 0.001);                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_13() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_14() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
            "    public void testCircleFitting$catena_15() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.0016, cov[1][1], 0.001);                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }"
        ]
    }
}