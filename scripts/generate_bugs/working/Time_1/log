---
Begin generate bug_id: Time_1
num_of_hunks: 3
timeout for running: 3600
use working dir: ./working/data/Time_1
Try to checkout Time_1
build dir: ['./working/data/Time_1/target/classes', './working/data/Time_1/target/test-classes']
init FileManager
trace file: src/main/java/org/joda/time/Partial.java
trace file: src/main/java/org/joda/time/field/UnsupportedDurationField.java
trying to replace old failing tests
edit: replace from 260 range 56 at src/test/java/org/joda/time/TestPartial_Constructors.java
to
    public void testConstructorEx7_TypeArray_intArray$catena_0() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            fail();                                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_1() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            assertMessageContains(ex, "must be in order", "largest-smallest");                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_2() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            fail();                                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_3() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            assertMessageContains(ex, "must be in order", "largest-smallest");                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_4() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            fail();                                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_5() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            assertMessageContains(ex, "must be in order", "largest-smallest");                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_6() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            fail();                                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_7() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            assertMessageContains(ex, "must be in order", "largest-smallest");                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_8() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            fail();                                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_9() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            assertMessageContains(ex, "must be in order", "largest-smallest");                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_10() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            fail();                                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
    }     public void testConstructorEx7_TypeArray_intArray$catena_11() throws Throwable {
        int[] values = new int[] {1, 1, 1};
        DateTimeFieldType[] types = new DateTimeFieldType[] {
            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            try{ assertMessageContains(ex, "must be in order", "largest-smallest");                         }catch(Throwable __SHOULD_BE_IGNORED){}
        }
        
        types = new DateTimeFieldType[] {
            DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };
        try {
            new Partial(types, values);
            try{ fail();                                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
        } catch (IllegalArgumentException ex) {
            assertMessageContains(ex, "must be in order", "largest-smallest");                              /***** ORIGINAL ASSERTION IS HERE *****/
        }
    }
trace file: src/test/java/org/joda/time/TestPartial_Constructors.java
new test num: 12
ori test num: 0
pattern: 000
patches are written to file
running tests...
used time: Finished in 41.43 seconds
Failing tests: 2
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_4
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_6
processed: 000
pattern: 001
try to fix hunk: 2
delete from 227 with range 3
patches are written to file
running tests...
used time: Finished in 35.45 seconds
Failing tests: 3
	org.joda.time.TestPartial_Basics::testWith_baseAndArgHaveNoRange
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_4
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_6
Includes new failing tests, set to unusable
processed: 001
pattern: 010
try to fix hunk: 1
replace from 221 with range 1 to
                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {

patches are written to file
running tests...
used time: Finished in 35.36 seconds
Failing tests: 2
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_4
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_6
No new failing tests but only 1 hunk
processed: 010
pattern: 100
try to fix hunk: 0
insert before 217 with                 if (loopUnitField.isSupported() == false) {
                    if (lastUnitField.isSupported()) {
                        throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                                        types[i - 1].getName() + " < " + loopType.getName());
                    } else {
                        throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " +
                                        types[i - 1].getName() + " and " + loopType.getName());
                    }
                }

patches are written to file
running tests...
used time: Finished in 33.84 seconds
Failing tests: 0
select new bug
Pattern: 100
new failing tests:
org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_4
org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_6
Save found bug
processed: 100
pattern: 011
try to fix hunk: 1
replace from 221 with range 1 to
                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {

try to fix hunk: 2
delete from 227 with range 3
patches are written to file
running tests...
used time: Finished in 30.78 seconds
Failing tests: 2
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_4
	org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray$catena_6
Can independently fix []
Could not fix independently
processed: 011
pattern: 101
try to fix hunk: 0
insert before 217 with                 if (loopUnitField.isSupported() == false) {
                    if (lastUnitField.isSupported()) {
                        throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                                        types[i - 1].getName() + " < " + loopType.getName());
                    } else {
                        throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " +
                                        types[i - 1].getName() + " and " + loopType.getName());
                    }
                }

try to fix hunk: 2
delete from 227 with range 3
patches are written to file
running tests...
used time: Finished in 36.67 seconds
Failing tests: 1
	org.joda.time.TestPartial_Basics::testWith_baseAndArgHaveNoRange
Includes new failing tests, set to unusable
processed: 101
pattern: 110
try to fix hunk: 0
insert before 217 with                 if (loopUnitField.isSupported() == false) {
                    if (lastUnitField.isSupported()) {
                        throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                                        types[i - 1].getName() + " < " + loopType.getName());
                    } else {
                        throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " +
                                        types[i - 1].getName() + " and " + loopType.getName());
                    }
                }

try to fix hunk: 1
replace from 221 with range 1 to
                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {

patches are written to file
running tests...
used time: Finished in 34.69 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 110
pattern: 111
try to fix hunk: 0
insert before 217 with                 if (loopUnitField.isSupported() == false) {
                    if (lastUnitField.isSupported()) {
                        throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                                        types[i - 1].getName() + " < " + loopType.getName());
                    } else {
                        throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " +
                                        types[i - 1].getName() + " and " + loopType.getName());
                    }
                }

try to fix hunk: 1
replace from 221 with range 1 to
                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {

try to fix hunk: 2
delete from 227 with range 3
patches are written to file
running tests...
used time: Finished in 31.12 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 111
Find 1 new bugs
