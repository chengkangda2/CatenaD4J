{
    "original": {
        "num_of_hunks": 2,
        "0": {
            "file_name": "src/main/java/org/apache/commons/math/util/MathUtils.java",
            "from_line_no": 1624,
            "to_line_no": 1624,
            "replaced_with": "      double sum = 0;\n",
            "replaced": "      int sum = 0;\n",
            "patch_type": "replace",
            "next_line_no": 1625
        },
        "1": {
            "file_name": "src/main/java/org/apache/commons/math/util/MathUtils.java",
            "from_line_no": 1626,
            "to_line_no": 1626,
            "replaced_with": "          final double dp = p1[i] - p2[i];\n",
            "replaced": "          final int dp = p1[i] - p2[i];\n",
            "patch_type": "replace",
            "next_line_no": 1627
        }
    },
    "method": {
        "failing_tests": [
            "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate"
        ],
        "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate": {
            "file_path": "src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java",
            "Instance": "Begin: Pos(102, 5)\nEnd: Pos(117, 5)\nSource: /root/workbench/exportInfo/d4j_buggy/Math_79/src/test/java//org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\nName: testPerformClusterAnalysisDegenerate\nChilds: [StatementAssertion<Begin: Pos(110, 9), End: Pos(110, 41)>,\nStatementAssertion<Begin: Pos(111, 9), End: Pos(111, 62)>,\nStatementAssertion<Begin: Pos(114, 9), End: Pos(114, 62)>,\nStatementAssertion<Begin: Pos(115, 9), End: Pos(115, 62)>,\n]",
            "source": "/root/workbench/exportInfo/d4j_buggy/Math_79/src/test/java//org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java",
            "name": "testPerformClusterAnalysisDegenerate",
            "begin": "Pos(102, 5)",
            "end": "Pos(117, 5)",
            "begin_line_no": 102,
            "end_line_no": 117,
            "child": [
                "Begin: Pos(110, 9)\nEnd: Pos(110, 41)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(111, 9)\nEnd: Pos(111, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(114, 9)\nEnd: Pos(114, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(115, 9)\nEnd: Pos(115, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_0() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        assertEquals(1, clusters.size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
                "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_1() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(2, (clusters.get(0).getPoints().size()));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
                "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_2() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        assertTrue(clusters.get(0).getPoints().contains(pt1));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
                "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_3() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertTrue(clusters.get(0).getPoints().contains(pt2));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    } "
            ],
            "func": {
                "0": "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_0() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        assertEquals(1, clusters.size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
                "1": "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_1() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(2, (clusters.get(0).getPoints().size()));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
                "2": "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_2() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        assertTrue(clusters.get(0).getPoints().contains(pt1));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
                "3": "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_3() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertTrue(clusters.get(0).getPoints().contains(pt2));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    } "
            }
        }
    },
    "01": {
        "failing_tests": [
            "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate$catena_0",
            "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate$catena_2",
            "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate$catena_1",
            "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate$catena_3"
        ]
    }
}