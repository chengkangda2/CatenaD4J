{
    "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize": {
        "begin_line_no": 69,
        "end_line_no": 128,
        "file_path": "src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java",
        "to": [
            "  @Test\n  public void testMinimizeMaximize$catena_9()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
            "  @Test\n  public void testMinimizeMaximize$catena_4()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
            "  @Test\n  public void testMinimizeMaximize$catena_5()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }"
        ]
    },
    "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMath283": {
        "begin_line_no": 192,
        "end_line_no": 217,
        "file_path": "src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java",
        "to": [
            "  @Test\n  public void testMath283$catena_2()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      try{ Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      try{ Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                                /***** ORIGINAL ASSERTION IS HERE *****/\n      \n  }",
            "  @Test\n  public void testMath283$catena_1()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      try{ Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                                /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      \n  }",
            "  @Test\n  public void testMath283$catena_0()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      try{ Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      \n  }"
        ]
    }
}