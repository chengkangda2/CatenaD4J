{
    "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate": {
        "begin_line_no": 102,
        "end_line_no": 117,
        "file_path": "src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java",
        "to": [
            "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_0() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        assertEquals(1, clusters.size());                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
            "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_2() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        assertTrue(clusters.get(0).getPoints().contains(pt1));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
            "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_1() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(2, (clusters.get(0).getPoints().size()));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt2));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    } ",
            "    @Test\n    public void testPerformClusterAnalysisDegenerate$catena_3() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        try{ assertEquals(1, clusters.size());                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(2, (clusters.get(0).getPoints().size()));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        try{ assertTrue(clusters.get(0).getPoints().contains(pt1));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertTrue(clusters.get(0).getPoints().contains(pt2));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    } "
        ]
    }
}