{
    "com.google.javascript.jscomp.NodeUtilTest::testLocalValue1": {
        "begin_line_no": 1073,
        "end_line_no": 1170,
        "file_path": "test/com/google/javascript/jscomp/NodeUtilTest.java",
        "to": [
            "  public void testLocalValue1$catena_60() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"delete a.b\"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
        ]
    }
}