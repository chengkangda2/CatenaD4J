---
Begin generate bug_id: Closure_167
num_of_hunks: 8
timeout for running: 3600
use working dir: ./working/data/Closure_167
Try to checkout Closure_167
build dir: ['./working/data/Closure_167/build/classes', './working/data/Closure_167/build/test']
init FileManager
trace file: src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java
trace file: src/com/google/javascript/rhino/jstype/JSType.java
trying to replace old failing tests
edit: replace from 5215 range 68 at test/com/google/javascript/rhino/jstype/JSTypeTest.java
to
  @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_0() {
    // simple cases
    assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_1() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_2() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_3() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_4() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_5() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_6() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_7() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_8() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_9() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_10() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_11() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_12() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_13() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_14() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_15() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_16() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_17() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_18() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_19() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        /***** ORIGINAL ASSERTION IS HERE *****/

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_20() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_21() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 /***** ORIGINAL ASSERTION IS HERE *****/

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_22() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                }catch(Throwable __SHOULD_BE_IGNORED){}
  }   @SuppressWarnings("checked")
      public void testRestrictedTypeGivenToBoolean$catena_23() {
    // simple cases
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(BOOLEAN_TYPE,
        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NULL_TYPE,
        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NUMBER_TYPE,
        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(STRING_TYPE,
        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(VOID_TYPE,
        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_OBJECT_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(NO_TYPE,
        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(ALL_TYPE,
        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTypeEquals(CHECKED_UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(UNKNOWN_TYPE,
        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    // unions
    UnionType nullableStringValue =
        (UnionType) createNullableType(STRING_TYPE);
    try{ assertTypeEquals(STRING_TYPE,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTypeEquals(nullableStringValue,
        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    UnionType nullableStringObject =
        (UnionType) createNullableType(STRING_OBJECT_TYPE);
    try{ assertTypeEquals(STRING_OBJECT_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTypeEquals(NULL_TYPE,
        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));                                /***** ORIGINAL ASSERTION IS HERE *****/
  }
trace file: test/com/google/javascript/rhino/jstype/JSTypeTest.java
new test num: 24
ori test num: 2
pattern: 00000000
patches are written to file
running tests...
used time: Finished in 261.82 seconds
Failing tests: 3
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20
	com.google.javascript.rhino.jstype.JSTypeTest::testRestrictedTypeGivenToBoolean$catena_18
processed: 00000000
pattern: 00000001
try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
used time: Finished in 249.04 seconds
Failing tests: 2
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20
select new bug
Pattern: 00000001
new failing tests:
com.google.javascript.rhino.jstype.JSTypeTest::testRestrictedTypeGivenToBoolean$catena_18
Save found bug
processed: 00000001
pattern: 00000010
try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
used time: Finished in 243.28 seconds
Failing tests: 10
	com.google.javascript.jscomp.LooseTypeCheckTest::testMissingProperty15
	com.google.javascript.jscomp.LooseTypeCheckTest::testMissingProperty21
	com.google.javascript.jscomp.LooseTypeCheckTest::testMissingProperty22
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty15
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty21
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty22
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty33
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty41
	com.google.javascript.rhino.jstype.JSTypeTest::testRestrictedTypeGivenToBoolean$catena_18
Includes new failing tests, set to unusable
processed: 00000010
pattern: 00000100
try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000100
pattern: 00001000
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000
pattern: 00010000
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000
pattern: 00100000
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

patches are written to file
running tests...
used time: Finished in 242.39 seconds
Failing tests: 3
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20
	com.google.javascript.rhino.jstype.JSTypeTest::testRestrictedTypeGivenToBoolean$catena_18
No new failing tests but only 1 hunk
processed: 00100000
pattern: 01000000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000
pattern: 10000000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000
pattern: 00000011
try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
used time: Finished in 242.57 seconds
Failing tests: 1
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
Can independently fix ['com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20']
select new bug
Pattern: 00000011
new failing tests:
com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20
Save found bug
processed: 00000011
pattern: 00000101
try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000101
pattern: 00000110
try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000110
pattern: 00001001
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001001
pattern: 00001010
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001010
pattern: 00001100
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001100
pattern: 00010001
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010001
pattern: 00010010
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010010
pattern: 00010100
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010100
pattern: 00011000
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011000
pattern: 00100001
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
used time: Finished in 230.91 seconds
Failing tests: 2
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty20
Can independently fix []
Could not fix independently
processed: 00100001
pattern: 00100010
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
used time: Finished in 239.34 seconds
Failing tests: 10
	com.google.javascript.jscomp.LooseTypeCheckTest::testMissingProperty15
	com.google.javascript.jscomp.LooseTypeCheckTest::testMissingProperty21
	com.google.javascript.jscomp.LooseTypeCheckTest::testMissingProperty22
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty15
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty21
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty22
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty33
	com.google.javascript.jscomp.TypeCheckTest::testMissingProperty41
	com.google.javascript.rhino.jstype.JSTypeTest::testRestrictedTypeGivenToBoolean$catena_18
Includes new failing tests, set to unusable
processed: 00100010
pattern: 00100100
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100100
pattern: 00101000
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101000
pattern: 00110000
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110000
pattern: 01000001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001
pattern: 01000010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010
pattern: 01000100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000100
pattern: 01001000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000
pattern: 01010000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000
pattern: 01100000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100000
pattern: 10000001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001
pattern: 10000010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010
pattern: 10000100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000100
pattern: 10001000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000
pattern: 10010000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000
pattern: 10100000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000
pattern: 11000000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000000
pattern: 00000111
try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000111
pattern: 00001011
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001011
pattern: 00001101
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001101
pattern: 00001110
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001110
pattern: 00010011
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010011
pattern: 00010101
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010101
pattern: 00010110
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010110
pattern: 00011001
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011001
pattern: 00011010
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011010
pattern: 00011100
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011100
pattern: 00100011
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
used time: Finished in 229.64 seconds
Failing tests: 1
	com.google.javascript.jscomp.TypeCheckTest::testIssue783
Can independently fix []
Could not fix independently
processed: 00100011
pattern: 00100101
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100101
pattern: 00100110
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100110
pattern: 00101001
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101001
pattern: 00101010
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101010
pattern: 00101100
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101100
pattern: 00110001
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110001
pattern: 00110010
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110010
pattern: 00110100
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110100
pattern: 00111000
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111000
pattern: 01000011
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000011
pattern: 01000101
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000101
pattern: 01000110
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000110
pattern: 01001001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001001
pattern: 01001010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001010
pattern: 01001100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001100
pattern: 01010001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010001
pattern: 01010010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010010
pattern: 01010100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010100
pattern: 01011000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011000
pattern: 01100001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100001
pattern: 01100010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100010
pattern: 01100100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100100
pattern: 01101000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101000
pattern: 01110000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110000
pattern: 10000011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000011
pattern: 10000101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000101
pattern: 10000110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000110
pattern: 10001001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001001
pattern: 10001010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001010
pattern: 10001100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001100
pattern: 10010001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010001
pattern: 10010010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010010
pattern: 10010100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010100
pattern: 10011000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011000
pattern: 10100001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100001
pattern: 10100010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100010
pattern: 10100100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100100
pattern: 10101000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101000
pattern: 10110000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110000
pattern: 11000001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000001
pattern: 11000010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000010
pattern: 11000100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000100
pattern: 11001000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001000
pattern: 11010000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010000
pattern: 11100000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100000
pattern: 00001111
try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001111
pattern: 00010111
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010111
pattern: 00011011
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011011
pattern: 00011101
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011101
pattern: 00011110
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011110
pattern: 00100111
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100111
pattern: 00101011
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101011
pattern: 00101101
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101101
pattern: 00101110
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101110
pattern: 00110011
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110011
pattern: 00110101
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110101
pattern: 00110110
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110110
pattern: 00111001
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111001
pattern: 00111010
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111010
pattern: 00111100
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111100
pattern: 01000111
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000111
pattern: 01001011
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001011
pattern: 01001101
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001101
pattern: 01001110
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001110
pattern: 01010011
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010011
pattern: 01010101
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010101
pattern: 01010110
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010110
pattern: 01011001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011001
pattern: 01011010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011010
pattern: 01011100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011100
pattern: 01100011
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100011
pattern: 01100101
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100101
pattern: 01100110
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100110
pattern: 01101001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101001
pattern: 01101010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101010
pattern: 01101100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101100
pattern: 01110001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110001
pattern: 01110010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110010
pattern: 01110100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110100
pattern: 01111000
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111000
pattern: 10000111
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000111
pattern: 10001011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001011
pattern: 10001101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001101
pattern: 10001110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001110
pattern: 10010011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010011
pattern: 10010101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010101
pattern: 10010110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010110
pattern: 10011001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011001
pattern: 10011010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011010
pattern: 10011100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011100
pattern: 10100011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100011
pattern: 10100101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100101
pattern: 10100110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100110
pattern: 10101001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101001
pattern: 10101010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101010
pattern: 10101100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101100
pattern: 10110001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110001
pattern: 10110010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110010
pattern: 10110100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110100
pattern: 10111000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111000
pattern: 11000011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000011
pattern: 11000101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000101
pattern: 11000110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000110
pattern: 11001001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001001
pattern: 11001010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001010
pattern: 11001100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001100
pattern: 11010001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010001
pattern: 11010010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010010
pattern: 11010100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010100
pattern: 11011000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011000
pattern: 11100001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100001
pattern: 11100010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100010
pattern: 11100100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100100
pattern: 11101000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11101000
pattern: 11110000
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110000
pattern: 00011111
try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011111
pattern: 00101111
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00101111
pattern: 00110111
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110111
pattern: 00111011
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111011
pattern: 00111101
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111101
pattern: 00111110
try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00111110
pattern: 01001111
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001111
pattern: 01010111
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010111
pattern: 01011011
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011011
pattern: 01011101
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011101
pattern: 01011110
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011110
pattern: 01100111
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100111
pattern: 01101011
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101011
pattern: 01101101
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101101
pattern: 01101110
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101110
pattern: 01110011
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110011
pattern: 01110101
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110101
pattern: 01110110
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110110
pattern: 01111001
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111001
pattern: 01111010
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111010
pattern: 01111100
try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111100
pattern: 10001111
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001111
pattern: 10010111
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010111
pattern: 10011011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011011
pattern: 10011101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011101
pattern: 10011110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011110
pattern: 10100111
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100111
pattern: 10101011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101011
pattern: 10101101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101101
pattern: 10101110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10101110
pattern: 10110011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110011
pattern: 10110101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110101
pattern: 10110110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110110
pattern: 10111001
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111001
pattern: 10111010
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111010
pattern: 10111100
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 2
replace from 394 with range 1 to
    if (restrictedType != null && restrictedType != originalType) {

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10111100
pattern: 11000111
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11000111
pattern: 11001011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001011
pattern: 11001101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001101
pattern: 11001110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 4
replace from 410 with range 1 to
        restrictedLeftType != null && restrictedLeftType != originalLeftType;

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001110
pattern: 11010011
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010011
pattern: 11010101
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 7
insert before 883 with     if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11010101
pattern: 11010110
try to fix hunk: 0
replace from 301 with range 2 to
          left, leftType, leftIsRefineable ? merged.typeA : null,
          right, rightType, rightIsRefineable ? merged.typeB : null);

try to fix hunk: 1
replace from 348 with range 2 to
          left, leftType, leftIsRefineable ? restrictedLeftType : null,
          right, rightType, rightIsRefineable ? restrictedRightType : null);

try to fix hunk: 3
replace from 407 with range 2 to
      Node left, JSType originalLeftType, JSType restrictedLeftType,
      Node right, JSType originalRightType, JSType restrictedRightType) {

try to fix hunk: 5
replace from 412 with range 1 to
        restrictedRightType != null && restrictedRightType != originalRightType;

try to fix hunk: 6
replace from 430 with range 5 to
      return maybeRestrictName(
          blindScope, name, type,
          type.getRestrictedTypeGivenToBooleanOutcome(outcome));

patches are written to file
running tests...
EXCEPTION: Inside Exception generator.run() timeout
Traceback (most recent call last):
  File "run.py", line 30, in task
    generator.run()
  File "/root/workbench/CatenaD4j/scripts/generateBugs/timeout_decorator/timeout_decorator.py", line 82, in new_function
    return function(*args, **kwargs)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/runner.py", line 83, in run
    self._run()
  File "/root/workbench/CatenaD4j/scripts/generateBugs/runner.py", line 109, in _run
    self.taskSingleHunk(task)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/runner.py", line 138, in taskSingleHunk
    failure = util.get_failing_tests(self.path, self.build_dir)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/util.py", line 46, in get_failing_tests
    result = runCommand(['defects4j', 'test', '-w', '{}'.format(path)], timeout=timeout)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/util.py", line 9, in runCommand
    finished = subprocess.run(cmd, capture_output=True, cwd=cwd, timeout=timeout)
  File "/usr/lib/python3.8/subprocess.py", line 495, in run
    stdout, stderr = process.communicate(input, timeout=timeout)
  File "/usr/lib/python3.8/subprocess.py", line 1028, in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
  File "/usr/lib/python3.8/subprocess.py", line 1868, in _communicate
    ready = selector.select(timeout)
  File "/usr/lib/python3.8/selectors.py", line 415, in select
    fd_event_list = self._selector.poll(timeout)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/timeout_decorator/timeout_decorator.py", line 69, in handler
    _raise_exception(timeout_exception, exception_message)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/timeout_decorator/timeout_decorator.py", line 47, in _raise_exception
    raise exception(exception_message)
TimeoutError: generator.run() timeout

