---
Begin generate bug_id: Closure_173
num_of_hunks: 3
use working dir: ./working/data/Closure_173
Try to checkout Closure_173
build dir: ['./working/data/Closure_173/build/classes', './working/data/Closure_173/build/test']
init FileManager
trace file: src/com/google/javascript/jscomp/CodeGenerator.java
trace file: src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
trace file: src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
trying to replace old failing tests
edit: replace from 166 range 205 at test/com/google/javascript/jscomp/CodePrinterTest.java
to
  public void testPrint$catena_0() {
    assertPrint("10 + a + b", "10+a+b");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_1() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("10 + (30*50)", "10+30*50");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_2() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_3() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("\"aa'a\"", "\"aa'a\"");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_4() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_5() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_6() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("a instanceof b", "a instanceof b");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_7() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("typeof(a)", "typeof a");                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_8() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           /***** ORIGINAL ASSERTION IS HERE *****/

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_9() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_10() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_11() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                        /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_12() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    assertPrint("while (x-- > 0);", "while(x-- >0);");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_13() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x-- >> 1", "x-- >>1");                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_14() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                /***** ORIGINAL ASSERTION IS HERE *****/

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_15() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_16() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_17() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_18() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_19() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_20() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_21() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               /***** ORIGINAL ASSERTION IS HERE *****/

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_22() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_23() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(delete a[0])/10", "delete a[0]/10");                                                      /***** ORIGINAL ASSERTION IS HERE *****/

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_24() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    assertPrint("new A", "new A");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_25() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("new A()", "new A");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_26() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("new A('x')", "new A(\"x\")");                                                              /***** ORIGINAL ASSERTION IS HERE *****/

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_27() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    assertPrint("new A().a()", "(new A).a()");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_28() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(new A).a()", "(new A).a()");                                                              /***** ORIGINAL ASSERTION IS HERE *****/

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_29() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                                    /***** ORIGINAL ASSERTION IS HERE *****/

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_30() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    assertPrint("new A.B", "new A.B");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_31() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("new A.B()", "new A.B");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_32() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("new A.B('z')", "new A.B(\"z\")");                                                          /***** ORIGINAL ASSERTION IS HERE *****/

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_33() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    assertPrint("(new A.B).a()", "(new A.B).a()");                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_34() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("new A.B().a()", "(new A.B).a()");                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_35() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                                /***** ORIGINAL ASSERTION IS HERE *****/

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_36() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    assertPrint("x + +y", "x+ +y");                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_37() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x - (-y)", "x- -y");                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_38() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x++ +y", "x++ +y");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_39() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x-- -y", "x-- -y");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_40() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x++ -y", "x++-y");                                                                         /***** ORIGINAL ASSERTION IS HERE *****/

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_41() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_42() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                                 /***** ORIGINAL ASSERTION IS HERE *****/

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_43() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    assertPrint("({})", "({})");                                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_44() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var x = {};", "var x={}");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_45() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({}).x", "({}).x");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_46() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({})['x']", "({})[\"x\"]");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_47() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({}) instanceof Object", "({})instanceof Object");                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_48() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({}) || 1", "({})||1");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_49() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("1 || ({})", "1||{}");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_50() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({}) ? 1 : 2", "({})?1:2");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_51() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("0 ? ({}) : 2", "0?{}:2");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_52() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("0 ? 1 : ({})", "0?1:{}");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_53() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("typeof ({})", "typeof{}");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_54() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("f({})", "f({})");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_55() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    assertPrint("(function(){})", "(function(){})");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_56() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(function(){})()", "(function(){})()");                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_57() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_58() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_59() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var x = function() { };", "var x=function(){}");                                           /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_60() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var x = function() { }();", "var x=function(){}()");                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_61() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(function() {}), 2", "(function(){}),2");                                                  /***** ORIGINAL ASSERTION IS HERE *****/

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_62() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    assertPrint("(function f(){})", "(function f(){})");                                                    /***** ORIGINAL ASSERTION IS HERE *****/

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_63() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    assertPrint("function f(){}", "function f(){}");                                                        /***** ORIGINAL ASSERTION IS HERE *****/

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_64() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_65() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                       /***** ORIGINAL ASSERTION IS HERE *****/

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_66() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    assertPrint("if (true) { alert();}", "if(true)alert()");                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_67() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_68() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("for(;;) { alert();};", "for(;;)alert()");                                                  /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_69() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_70() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_71() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_72() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                            /***** ORIGINAL ASSERTION IS HERE *****/

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_73() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    assertPrint("\\u00fb", "\\u00fb");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_74() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("\\u00fa=1", "\\u00fa=1");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_75() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_76() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x.\\u00f8", "x.\\u00f8");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_77() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x.\\u00f8", "x.\\u00f8");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_78() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                            /***** ORIGINAL ASSERTION IS HERE *****/

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_79() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    assertPrint("! ! true", "!!true");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_80() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("!(!(true))", "!!true");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_81() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("typeof(void(0))", "typeof void 0");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_82() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("typeof(void(!0))", "typeof void!0");                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_83() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("+ - + + - + 3", "+-+ +-+3");                                   /***** ORIGINAL ASSERTION IS HERE *****/ // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_84() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    assertPrint("+(--x)", "+--x");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_85() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("-(++x)", "-++x");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_86() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    assertPrint("-(--x)", "- --x");                                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_87() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("!(~~5)", "!~~5");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_88() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("~(a/b)", "~(a/b)");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_89() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_90() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_91() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                /***** ORIGINAL ASSERTION IS HERE *****/

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_92() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_93() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_94() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                      /***** ORIGINAL ASSERTION IS HERE *****/

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_95() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                                /***** ORIGINAL ASSERTION IS HERE *****/

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_96() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    assertPrint("a,b,c", "a,b,c");                                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_97() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("(a,b),c", "a,b,c");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_98() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("a,(b,c)", "a,b,c");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_99() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=a,b,c", "x=a,b,c");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_100() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=(a,b),c", "x=(a,b),c");                                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_101() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=a,(b,c)", "x=a,b,c");                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_102() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_103() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_104() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_105() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_106() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_107() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_108() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var x=(a,b)", "var x=(a,b)");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_109() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var x=a,b,c", "var x=a,b,c");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_110() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                          /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_111() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_112() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_113() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_114() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_115() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_116() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({}) , 1 , 2", "({}),1,2");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_117() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("({}) , {} , {}", "({}),{},{}");                                                            /***** ORIGINAL ASSERTION IS HERE *****/

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_118() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    assertPrint("if (x){}", "if(x);");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_119() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("if(x);", "if(x);");                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_120() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("if(x)if(y);", "if(x)if(y);");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_121() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("if(x){if(y);}", "if(x)if(y);");                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_122() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                 }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testPrint$catena_123() {
    try{ assertPrint("10 + a + b", "10+a+b");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("10 + (30*50)", "10+30*50");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("with(x) { x + 3; }", "with(x)x+3");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa'a\"", "\"aa'a\"");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\"aa\\\"a\"", "'aa\"a'");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function foo()\n{return 10;}", "function foo(){return 10}");                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a instanceof b", "a instanceof b");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(a)", "typeof a");                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint(
        "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}",
        "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Safari: needs ';' at the end of a throw statement
    try{ assertPrint("function foo(){throw 'error';}",
        "function foo(){throw\"error\";}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Safari 3 needs a "{" around a single function
    try{ assertPrint("if (true) function foo(){return}",
        "if(true){function foo(){return}}");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("while (x-- > 0);", "while(x-- >0);");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- >> 1", "x-- >>1");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("(function () {})(); ",
        "(function(){})()");                                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Associativity
    try{ assertPrint("var a,b,c,d;a || (b&& c) && (a || d)",
        "var a,b,c,d;a||b&&c&&(a||d)");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c;a||(b||c);a*(b*c);a|(b|c)");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);",
        "var a,b,c;a/b/c;a/(b/c);a-(b-c)");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Nested assignments
    try{ assertPrint("var a,b; a = b = 3;",
        "var a,b;a=b=3");                                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c,d; a = (b = c = (d = 3));",
        "var a,b,c,d;a=b=c=d=3");                                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a += (b = c += 3);",
        "var a,b,c;a+=b=c+=3");                                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var a,b,c; a *= (b -= c);",
        "var a,b,c;a*=b-=c");                                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Precedence
    try{ assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(delete a[0])/10", "delete a[0]/10");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // optional '()' for new

    // simple new
    try{ assertPrint("new A", "new A");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A()", "new A");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A('x')", "new A(\"x\")");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new
    try{ assertPrint("new A().a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(new A).a()", "(new A).a()");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // this case should be fixed
    try{ assertPrint("new A('y').a()", "(new A(\"y\")).a()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // internal class
    try{ assertPrint("new A.B", "new A.B");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B()", "new A.B");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B('z')", "new A.B(\"z\")");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // calling instance method directly after new internal class
    try{ assertPrint("(new A.B).a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new A.B().a()", "(new A.B).a()");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    // this case should be fixed
    try{ assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Operators: make sure we don't convert binary + and unary + into ++
    try{ assertPrint("x + +y", "x+ +y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x - (-y)", "x- -y");                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ +y", "x++ +y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x-- -y", "x-- -y");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x++ -y", "x++-y");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}

    // Label
    try{ assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo");                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // Object literals.
    try{ assertPrint("({})", "({})");                                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = {};", "var x={}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}).x", "({}).x");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({})['x']", "({})[\"x\"]");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) instanceof Object", "({})instanceof Object");                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) || 1", "({})||1");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("1 || ({})", "1||{}");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) ? 1 : 2", "({})?1:2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? ({}) : 2", "0?{}:2");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("0 ? 1 : ({})", "0?1:{}");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof ({})", "typeof{}");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f({})", "f({})");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Anonymous function expressions.
    try{ assertPrint("(function(){})", "(function(){})");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})()", "(function(){})()");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){})instanceof Object",
        "(function(){})instanceof Object");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function(){}).bind().call()",
        "(function(){}).bind().call()");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { };", "var x=function(){}");                                      }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x = function() { }();", "var x=function(){}()");                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(function() {}), 2", "(function(){}),2");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Name functions expression.
    try{ assertPrint("(function f(){})", "(function f(){})");                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Function declaration.
    try{ assertPrint("function f(){}", "function f(){}");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure we don't treat non-Latin character escapes as raw strings.
    try{ assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})");                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})");                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test if statement and for statements with single statements in body.
    try{ assertPrint("if (true) { alert();}", "if(true)alert()");                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if (false) {} else {alert(\"a\");}",
        "if(false);else alert(\"a\")");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("for(;;) { alert();};", "for(;;)alert()");                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertPrint("do { alert(); } while(true);",
        "do alert();while(true)");                                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: { alert();}",
        "myLabel:alert()");                                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("myLabel: for(;;) continue myLabel;",
        "myLabel:for(;;)continue myLabel");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested var statement
    try{ assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Non-latin identifier. Make sure we keep them escaped.
    try{ assertPrint("\\u00fb", "\\u00fb");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("\\u00fa=1", "\\u00fa=1");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("function \\u00f9(){}", "function \\u00f9(){}");                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x.\\u00f8", "x.\\u00f8");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl");                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test the right-associative unary operators for spurious parens
    try{ assertPrint("! ! true", "!!true");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(!(true))", "!!true");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(0))", "typeof void 0");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("typeof(void(!0))", "typeof void!0");                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("+ - + + - + 3", "+-+ +-+3");                              }catch(Throwable __SHOULD_BE_IGNORED){} // chained unary plus/minus
    try{ assertPrint("+(--x)", "+--x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("-(++x)", "-++x");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // needs a space to prevent an ambiguous parse
    try{ assertPrint("-(--x)", "- --x");                                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("!(~~5)", "!~~5");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("~(a/b)", "~(a/b)");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    // Preserve parens to overcome greedy binding of NEW
    try{ assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)");                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)");                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("new (new foobar(x)).factory(baz)",
        "new (new foobar(x)).factory(baz)");                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // Make sure that HOOK is right associative
    try{ assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test nested ifs
    try{ assertPrint("if (x) if (y); else;", "if(x)if(y);else;");                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    // Test comma.
    try{ assertPrint("a,b,c", "a,b,c");                                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("(a,b),c", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("a,(b,c)", "a,b,c");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,b,c", "x=a,b,c");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,b),c", "x=(a,b),c");                                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,(b,c)", "x=a,b,c");                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b)", "var x=(a,b)");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b,c", "var x=a,b,c");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=(a,b),c", "var x=(a,b),c");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))");                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , 1 , 2", "({}),1,2");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("({}) , {} , {}", "({}),{},{}");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}

    // EMPTY nodes
    try{ assertPrint("if (x){}", "if(x);");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x);", "if(x);");                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x)if(y);", "if(x)if(y);");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y);}", "if(x)if(y);");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertPrint("if(x){if(y){};;;}", "if(x)if(y);");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}");                                      /***** ORIGINAL ASSERTION IS HERE *****/
  }
edit: replace from 458 range 5 at test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java
to
  public void testAssocitivity$catena_0() {
    test("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c; (a || b) || c; (a * b) * c; (a | b) | c");                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ testSame("var a,b,c; a % (b % c); a / (b / c); a - (b - c);");                                     }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testAssocitivity$catena_1() {
    try{ test("var a,b,c; a || (b || c); a * (b * c); a | (b | c)",
        "var a,b,c; (a || b) || c; (a * b) * c; (a | b) | c");                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    testSame("var a,b,c; a % (b % c); a / (b / c); a - (b - c);");                                          /***** ORIGINAL ASSERTION IS HERE *****/
  }
trace file: test/com/google/javascript/jscomp/CodePrinterTest.java
trace file: test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java
new test num: 126
ori test num: 1
pattern: 000
patches are written to file
running tests...
used time: Finished in 275.04 seconds
Failing tests: 3
	com.google.javascript.jscomp.CodePrinterTest::testPrint$catena_16
	com.google.javascript.jscomp.CodePrinterTest::testIssue1062
	com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity$catena_0
pattern: 001
try to fix hunk: 2
insert before 108 with   private Node tryRotateAssociativeOperator(Node n) {
    if (!late) {
      return n;
    }
    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
    Node rhs = n.getLastChild();
    if (n.getType() == rhs.getType()) {
      Node parent = n.getParent();
      Node first = n.getFirstChild().detachFromParent();
      Node second = rhs.getFirstChild().detachFromParent();
      Node third = rhs.getLastChild().detachFromParent();
      Node newLhs = new Node(n.getType(), first, second)
          .copyInformationFrom(n);
      Node newRoot = new Node(rhs.getType(), newLhs, third)
          .copyInformationFrom(rhs);
      parent.replaceChild(n, newRoot);
      reportCodeChange();
      return newRoot;
    }
    return n;
  }

patches are written to file
running tests...
used time: Finished in 276.14 seconds
Failing tests: 3
	com.google.javascript.jscomp.CodePrinterTest::testPrint$catena_16
	com.google.javascript.jscomp.CodePrinterTest::testIssue1062
	com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity$catena_0
No new failing tests but only 1 hunk
pattern: 010
try to fix hunk: 1
insert before 102 with       case Token.MUL:
      case Token.AND:
      case Token.OR:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
        return tryRotateAssociativeOperator(node);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 100
try to fix hunk: 0
replace from 130 with range 6 to
      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {

patches are written to file
running tests...
used time: Finished in 286.81 seconds
Failing tests: 1
	com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity$catena_0
No new failing tests but only 1 hunk
pattern: 011
try to fix hunk: 1
insert before 102 with       case Token.MUL:
      case Token.AND:
      case Token.OR:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
        return tryRotateAssociativeOperator(node);

try to fix hunk: 2
insert before 108 with   private Node tryRotateAssociativeOperator(Node n) {
    if (!late) {
      return n;
    }
    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
    Node rhs = n.getLastChild();
    if (n.getType() == rhs.getType()) {
      Node parent = n.getParent();
      Node first = n.getFirstChild().detachFromParent();
      Node second = rhs.getFirstChild().detachFromParent();
      Node third = rhs.getLastChild().detachFromParent();
      Node newLhs = new Node(n.getType(), first, second)
          .copyInformationFrom(n);
      Node newRoot = new Node(rhs.getType(), newLhs, third)
          .copyInformationFrom(rhs);
      parent.replaceChild(n, newRoot);
      reportCodeChange();
      return newRoot;
    }
    return n;
  }

patches are written to file
running tests...
used time: Finished in 279.72 seconds
Failing tests: 2
	com.google.javascript.jscomp.CodePrinterTest::testPrint$catena_16
	com.google.javascript.jscomp.CodePrinterTest::testIssue1062
Can independently fix ['com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity$catena_0']
select new bug
Pattern: 011
failing tests: com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity$catena_0
pattern: 101
try to fix hunk: 0
replace from 130 with range 6 to
      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {

try to fix hunk: 2
insert before 108 with   private Node tryRotateAssociativeOperator(Node n) {
    if (!late) {
      return n;
    }
    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
    Node rhs = n.getLastChild();
    if (n.getType() == rhs.getType()) {
      Node parent = n.getParent();
      Node first = n.getFirstChild().detachFromParent();
      Node second = rhs.getFirstChild().detachFromParent();
      Node third = rhs.getLastChild().detachFromParent();
      Node newLhs = new Node(n.getType(), first, second)
          .copyInformationFrom(n);
      Node newRoot = new Node(rhs.getType(), newLhs, third)
          .copyInformationFrom(rhs);
      parent.replaceChild(n, newRoot);
      reportCodeChange();
      return newRoot;
    }
    return n;
  }

patches are written to file
running tests...
used time: Finished in 294.86 seconds
Failing tests: 1
	com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testAssocitivity$catena_0
Can independently fix []
Could not fix independently
pattern: 110
try to fix hunk: 0
replace from 130 with range 6 to
      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {

try to fix hunk: 1
insert before 102 with       case Token.MUL:
      case Token.AND:
      case Token.OR:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
        return tryRotateAssociativeOperator(node);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 111
try to fix hunk: 0
replace from 130 with range 6 to
      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {

try to fix hunk: 1
insert before 102 with       case Token.MUL:
      case Token.AND:
      case Token.OR:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
        return tryRotateAssociativeOperator(node);

try to fix hunk: 2
insert before 108 with   private Node tryRotateAssociativeOperator(Node n) {
    if (!late) {
      return n;
    }
    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
    Node rhs = n.getLastChild();
    if (n.getType() == rhs.getType()) {
      Node parent = n.getParent();
      Node first = n.getFirstChild().detachFromParent();
      Node second = rhs.getFirstChild().detachFromParent();
      Node third = rhs.getLastChild().detachFromParent();
      Node newLhs = new Node(n.getType(), first, second)
          .copyInformationFrom(n);
      Node newRoot = new Node(rhs.getType(), newLhs, third)
          .copyInformationFrom(rhs);
      parent.replaceChild(n, newRoot);
      reportCodeChange();
      return newRoot;
    }
    return n;
  }

patches are written to file
running tests...
used time: Finished in 285.43 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
Find 1 new bugs
