---
Begin generate bug_id: Closure_148
num_of_hunks: 65
NOTICE: may not contains full fix patterns for hunks are too much (65 hunks)
timeout for running: 3600
use working dir: ./working/data/Closure_148
Try to checkout Closure_148
build dir: ['./working/data/Closure_148/build/classes', './working/data/Closure_148/build/test']
init FileManager
trace file: src/com/google/javascript/jscomp/PeepholeFoldConstants.java
trace file: src/com/google/javascript/jscomp/SourceMap.java
trying to replace old failing tests
edit: replace from 545 range 16 at test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
to
  public void testFoldTypeof$catena_0() {
    fold("x = typeof 1", "x = \"number\"");                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_1() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof 'foo'", "x = \"string\"");                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_2() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof true", "x = \"boolean\"");                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_3() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof false", "x = \"boolean\"");                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_4() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof null", "x = \"object\"");                                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_5() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof undefined", "x = \"undefined\"");                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_6() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof void 0", "x = \"undefined\"");                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_7() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof []", "x = \"object\"");                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_8() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof [1]", "x = \"object\"");                                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_9() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof [1,[]]", "x = \"object\"");                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_10() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    fold("x = typeof {}", "x = \"object\"");                                                                /***** ORIGINAL ASSERTION IS HERE *****/

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_11() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    foldSame("x = typeof[1,[foo()]]");                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ foldSame("x = typeof{bathwater:baby()}");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testFoldTypeof$catena_12() {
    try{ fold("x = typeof 1", "x = \"number\"");                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof 'foo'", "x = \"string\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof true", "x = \"boolean\"");                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof false", "x = \"boolean\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof null", "x = \"object\"");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof undefined", "x = \"undefined\"");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof void 0", "x = \"undefined\"");                                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof []", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1]", "x = \"object\"");                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof [1,[]]", "x = \"object\"");                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ fold("x = typeof {}", "x = \"object\"");                                                           }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ foldSame("x = typeof[1,[foo()]]");                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    foldSame("x = typeof{bathwater:baby()}");                                                               /***** ORIGINAL ASSERTION IS HERE *****/
  }
trace file: test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
new test num: 13
ori test num: 5
pattern: 00000000000000000000000000000000000000000000000000000000000000000
patches are written to file
running tests...
used time: Finished in 138.34 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
processed: 00000000000000000000000000000000000000000000000000000000000000000
pattern: 10000000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

patches are written to file
running tests...
used time: Finished in 123.06 seconds
Failing tests: 5
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
select new bug
Pattern: 10000000000000000000000000000000000000000000000000000000000000000
new failing tests:
com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
Save found bug
processed: 10000000000000000000000000000000000000000000000000000000000000000
pattern: 01000000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

patches are written to file
running tests...
used time: Finished in 117.30 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
No new failing tests but only 1 hunk
processed: 01000000000000000000000000000000000000000000000000000000000000000
pattern: 00100000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 2
replace from 50 with range 1 to
    int id = UNMAPPED;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100000000000000000000000000000000000000000000000000000000000000
pattern: 00010000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 3
insert before 85 with     boolean used = false;
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00010000000000000000000000000000000000000000000000000000000000000
pattern: 00001000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 4
insert before 86 with   private class MappingWriter {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001000000000000000000000000000000000000000000000000000000000000
pattern: 00000100000000000000000000000000000000000000000000000000000000000
try to fix hunk: 5
insert before 89 with     private String lastSourceFile = null;
    private String lastSourceFileEscaped = null;
    private int lastLine = 0;
    private String lastLineString = String.valueOf(0);

patches are written to file
running tests...
used time: Finished in 113.42 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
No new failing tests but only 1 hunk
processed: 00000100000000000000000000000000000000000000000000000000000000000
pattern: 00000010000000000000000000000000000000000000000000000000000000000
try to fix hunk: 6
replace from 93 with range 1 to
    private void appendMappingTo(
        Mapping m, Appendable out) throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000010000000000000000000000000000000000000000000000000000000000
pattern: 00000001000000000000000000000000000000000000000000000000000000000
try to fix hunk: 7
replace from 96 with range 1 to
      String sourceFile = m.sourceFile;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000001000000000000000000000000000000000000000000000000000000000
pattern: 00000000100000000000000000000000000000000000000000000000000000000
try to fix hunk: 8
insert before 98 with       String escapedSourceFile;
      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
      }
      escapedSourceFile = lastSourceFileEscaped;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000100000000000000000000000000000000000000000000000000000000
pattern: 00000000010000000000000000000000000000000000000000000000000000000
try to fix hunk: 9
insert before 99 with       out.append(escapedSourceFile);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000010000000000000000000000000000000000000000000000000000000
pattern: 00000000001000000000000000000000000000000000000000000000000000000
try to fix hunk: 10
insert before 101 with       int line = m.originalPosition.getLineNumber();
      if (line != lastLine) {
        lastLineString = String.valueOf(line);
      }
      String lineValue = lastLineString;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000001000000000000000000000000000000000000000000000000000000
pattern: 00000000000100000000000000000000000000000000000000000000000000000
try to fix hunk: 11
replace from 102 with range 1 to
      out.append(lineValue);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000100000000000000000000000000000000000000000000000000000
pattern: 00000000000010000000000000000000000000000000000000000000000000000
try to fix hunk: 12
replace from 105 with range 1 to
      out.append(String.valueOf(
          m.originalPosition.getCharacterIndex()));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000010000000000000000000000000000000000000000000000000000
pattern: 00000000000001000000000000000000000000000000000000000000000000000
try to fix hunk: 13
replace from 107 with range 1 to
      if (m.originalName != null) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000001000000000000000000000000000000000000000000000000000
pattern: 00000000000000100000000000000000000000000000000000000000000000000
try to fix hunk: 14
replace from 109 with range 1 to
        out.append(escapeString(m.originalName));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000100000000000000000000000000000000000000000000000000
pattern: 00000000000000010000000000000000000000000000000000000000000000000
try to fix hunk: 15
replace from 112 with range 1 to
      out.append("]\n");

patches are written to file
running tests...
used time: Finished in 112.64 seconds
Failing tests: 10
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 00000000000000010000000000000000000000000000000000000000000000000
pattern: 00000000000000001000000000000000000000000000000000000000000000000
try to fix hunk: 16
insert before 114 with 

patches are written to file
running tests...
used time: Finished in 116.93 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
No new failing tests but only 1 hunk
processed: 00000000000000001000000000000000000000000000000000000000000000000
pattern: 00000000000000000100000000000000000000000000000000000000000000000
try to fix hunk: 17
insert before 117 with     void appendMappings(Appendable out) throws IOException {
      for (Mapping m : mappings) {
        if (m.used) {
          appendMappingTo(m, out);
        }
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000100000000000000000000000000000000000000000000000
pattern: 00000000000000000010000000000000000000000000000000000000000000000
try to fix hunk: 18
delete from 143 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000010000000000000000000000000000000000000000000000
pattern: 00000000000000000001000000000000000000000000000000000000000000000
try to fix hunk: 19
delete from 163 with range 6
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000001000000000000000000000000000000000000000000000
pattern: 00000000000000000000100000000000000000000000000000000000000000000
try to fix hunk: 20
replace from 171 with range 2 to
    mapping.sourceFile = sourceFile;

patches are written to file
running tests...
used time: Finished in 111.62 seconds
Failing tests: 10
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 00000000000000000000100000000000000000000000000000000000000000000
pattern: 00000000000000000000010000000000000000000000000000000000000000000
try to fix hunk: 21
replace from 177 with range 1 to
      mapping.originalName = originalName;

patches are written to file
running tests...
used time: Finished in 121.56 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
No new failing tests but only 1 hunk
processed: 00000000000000000000010000000000000000000000000000000000000000000
pattern: 00000000000000000000001000000000000000000000000000000000000000000
try to fix hunk: 22
insert before 180 with     if (offsetPosition.getLineNumber() == 0
        && offsetPosition.getCharacterIndex() == 0) {
      mapping.startPosition = startPosition;
      mapping.endPosition = endPosition;
    } else {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000001000000000000000000000000000000000000000000
pattern: 00000000000000000000000100000000000000000000000000000000000000000
try to fix hunk: 23
insert before 203 with     }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000100000000000000000000000000000000000000000
pattern: 00000000000000000000000010000000000000000000000000000000000000000
try to fix hunk: 24
delete from 257 with range 8
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000010000000000000000000000000000000000000000
pattern: 00000000000000000000000001000000000000000000000000000000000000000
try to fix hunk: 25
replace from 304 with range 1 to
    int maxLine = prepMappings();

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000001000000000000000000000000000000000000000
pattern: 00000000000000000000000000100000000000000000000000000000000000000
try to fix hunk: 26
replace from 326 with range 4 to
    (new MappingWriter()).appendMappings(out);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000100000000000000000000000000000000000000
pattern: 00000000000000000000000000010000000000000000000000000000000000000
try to fix hunk: 27
insert before 335 with   private int prepMappings() throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000010000000000000000000000000000000000000
pattern: 00000000000000000000000000001000000000000000000000000000000000000
try to fix hunk: 28
insert before 336 with     (new MappingTraversal()).traverse(new UsedMappingCheck());

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000001000000000000000000000000000000000000
pattern: 00000000000000000000000000000100000000000000000000000000000000000
try to fix hunk: 29
insert before 338 with     int id = 0;
    int maxLine = 0;
    for (Mapping m : mappings) {
      if (m.used) {
        m.id = id++;
        int endPositionLine = m.endPosition.getLineNumber();
        maxLine = Math.max(maxLine, endPositionLine);
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000100000000000000000000000000000000000
pattern: 00000000000000000000000000000010000000000000000000000000000000000
try to fix hunk: 30
insert before 340 with     return maxLine + prefixPosition.getLineNumber();
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000010000000000000000000000000000000000
pattern: 00000000000000000000000000000001000000000000000000000000000000000
try to fix hunk: 31
replace from 341 with range 1 to
  private class LineMapper implements MappingVisitor {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000001000000000000000000000000000000000
pattern: 00000000000000000000000000000000100000000000000000000000000000000
try to fix hunk: 32
replace from 344 with range 2 to


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000100000000000000000000000000000000
pattern: 00000000000000000000000000000000010000000000000000000000000000000
try to fix hunk: 33
replace from 351 with range 1 to
    private int lastId = UNMAPPED;
    private String lastIdString = UNMAPPED_STRING;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000010000000000000000000000000000000
pattern: 00000000000000000000000000000000001000000000000000000000000000000
try to fix hunk: 34
insert before 360 with     public void visit(Mapping m, int line, int col, int nextLine, int nextCol)
      throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000001000000000000000000000000000000
pattern: 00000000000000000000000000000000000100000000000000000000000000000
try to fix hunk: 35
insert before 361 with       int id = (m != null) ? m.id : UNMAPPED;
      if (lastId != id) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000100000000000000000000000000000
pattern: 00000000000000000000000000000000000010000000000000000000000000000
try to fix hunk: 36
insert before 363 with         lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);
        lastId = id;
      }
      String idString = lastIdString;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000010000000000000000000000000000
pattern: 00000000000000000000000000000000000001000000000000000000000000000
try to fix hunk: 37
insert before 364 with       for (int i = line; i <= nextLine; i++) {
        if (i == nextLine) {
          for (int j = col; j < nextCol; j++) {
            addCharEntry(idString);
          }
          break;
        }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000001000000000000000000000000000
pattern: 00000000000000000000000000000000000000100000000000000000000000000
try to fix hunk: 38
insert before 365 with         closeLine();
        openLine();
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000100000000000000000000000000
pattern: 00000000000000000000000000000000000000010000000000000000000000000
try to fix hunk: 39
insert before 373 with       (new MappingTraversal()).traverse(this);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000010000000000000000000000000
pattern: 00000000000000000000000000000000000000001000000000000000000000000
try to fix hunk: 40
insert before 375 with       closeLine();
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000001000000000000000000000000
pattern: 00000000000000000000000000000000000000000100000000000000000000000
try to fix hunk: 41
insert before 379 with     private void openLine() throws IOException {
      if (out != null) {
        out.append("[");
        this.firstChar = true;
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000100000000000000000000000
pattern: 00000000000000000000000000000000000000000010000000000000000000000
try to fix hunk: 42
insert before 383 with     private void closeLine() throws IOException {
      if (out != null) {
        out.append("]\n");
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000010000000000000000000000
pattern: 00000000000000000000000000000000000000000001000000000000000000000
try to fix hunk: 43
insert before 388 with     private void addCharEntry(String id) throws IOException {
      if (out != null) {
        if (firstChar) {
          firstChar = false;
        } else {
          out.append(",");
        }
        out.append(id);
      }
    }
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000001000000000000000000000
pattern: 00000000000000000000000000000000000000000000100000000000000000000
try to fix hunk: 44
insert before 392 with   private class UsedMappingCheck implements MappingVisitor {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000100000000000000000000
pattern: 00000000000000000000000000000000000000000000010000000000000000000
try to fix hunk: 45
insert before 395 with     @Override
    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)
        throws IOException {
      if (m != null) {
        m.used = true;
      }
    }
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000010000000000000000000
pattern: 00000000000000000000000000000000000000000000001000000000000000000
try to fix hunk: 46
insert before 396 with   private interface MappingVisitor {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000001000000000000000000
pattern: 00000000000000000000000000000000000000000000000100000000000000000
try to fix hunk: 47
insert before 405 with     void visit(Mapping m, int line, int col, int endLine, int endCol)
        throws IOException;
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000100000000000000000
pattern: 00000000000000000000000000000000000000000000000010000000000000000
try to fix hunk: 48
insert before 410 with   private class MappingTraversal {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000010000000000000000
pattern: 00000000000000000000000000000000000000000000000001000000000000000
try to fix hunk: 49
insert before 411 with     private int line;
    private int col;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000001000000000000000
pattern: 00000000000000000000000000000000000000000000000000100000000000000
try to fix hunk: 50
insert before 412 with     MappingTraversal() {
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000100000000000000
pattern: 00000000000000000000000000000000000000000000000000010000000000000
try to fix hunk: 51
insert before 414 with     void traverse(MappingVisitor v) throws IOException {
      Preconditions.checkState(!mappings.isEmpty());

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000010000000000000
pattern: 00000000000000000000000000000000000000000000000000001000000000000
try to fix hunk: 52
replace from 426 with range 1 to
          maybeVisit(v, previous);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000001000000000000
pattern: 00000000000000000000000000000000000000000000000000000100000000000
try to fix hunk: 53
replace from 432 with range 1 to
        maybeVisitParent(v, parent, m);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000100000000000
pattern: 00000000000000000000000000000000000000000000000000000010000000000
try to fix hunk: 54
replace from 441 with range 16 to
        maybeVisit(v, m);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000010000000000
pattern: 00000000000000000000000000000000000000000000000000000001000000000
try to fix hunk: 55
delete from 458 with range 1
patches are written to file
running tests...
used time: Finished in 120.58 seconds
Failing tests: 10
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 00000000000000000000000000000000000000000000000000000001000000000
pattern: 00000000000000000000000000000000000000000000000000000000100000000
try to fix hunk: 56
replace from 496 with range 1 to
    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000000100000000
pattern: 00000000000000000000000000000000000000000000000000000000010000000
try to fix hunk: 57
replace from 502 with range 1 to
        visit(v, m, nextLine, nextCol);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000000010000000
pattern: 00000000000000000000000000000000000000000000000000000000001000000
try to fix hunk: 58
replace from 509 with range 1 to
    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000000001000000
pattern: 00000000000000000000000000000000000000000000000000000000000100000
try to fix hunk: 59
replace from 511 with range 2 to
      int nextLine = getAdjustedLine(m.startPosition);
      int nextCol = getAdjustedCol(m.startPosition);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000000000100000
pattern: 00000000000000000000000000000000000000000000000000000000000010000
try to fix hunk: 60
replace from 514 with range 2 to
      Preconditions.checkState(line < nextLine || col <= nextCol);
      if (line < nextLine || (line == nextLine && col < nextCol)) {
        visit(v, parent, nextLine, nextCol);
      }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000000000010000
pattern: 00000000000000000000000000000000000000000000000000000000000001000
try to fix hunk: 61
replace from 522 with range 2 to
    private void visit(MappingVisitor v, Mapping m,
        int nextLine, int nextCol)

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000000000001000
pattern: 00000000000000000000000000000000000000000000000000000000000000100
try to fix hunk: 62
replace from 525 with range 2 to
      Preconditions.checkState(line <= nextLine);
      Preconditions.checkState(line < nextLine || col < nextCol);

patches are written to file
running tests...
used time: Finished in 123.45 seconds
Failing tests: 11
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicDeterminism
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 00000000000000000000000000000000000000000000000000000000000000100
pattern: 00000000000000000000000000000000000000000000000000000000000000010
try to fix hunk: 63
insert before 530 with         Preconditions.checkState(false);

patches are written to file
running tests...
used time: Finished in 126.42 seconds
Failing tests: 11
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicDeterminism
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 00000000000000000000000000000000000000000000000000000000000000010
pattern: 00000000000000000000000000000000000000000000000000000000000000001
try to fix hunk: 64
replace from 533 with range 11 to
      v.visit(m, line, col, nextLine, nextCol);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00000000000000000000000000000000000000000000000000000000000000001
pattern: 11000000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

patches are written to file
running tests...
used time: Finished in 125.44 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Can independently fix []
Could not fix independently
processed: 11000000000000000000000000000000000000000000000000000000000000000
pattern: 10100000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 2
replace from 50 with range 1 to
    int id = UNMAPPED;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100000000000000000000000000000000000000000000000000000000000000
pattern: 10010000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 3
insert before 85 with     boolean used = false;
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10010000000000000000000000000000000000000000000000000000000000000
pattern: 10001000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 4
insert before 86 with   private class MappingWriter {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001000000000000000000000000000000000000000000000000000000000000
pattern: 10000100000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 5
insert before 89 with     private String lastSourceFile = null;
    private String lastSourceFileEscaped = null;
    private int lastLine = 0;
    private String lastLineString = String.valueOf(0);

patches are written to file
running tests...
used time: Finished in 121.05 seconds
Failing tests: 5
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Can independently fix []
Could not fix independently
processed: 10000100000000000000000000000000000000000000000000000000000000000
pattern: 10000010000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 6
replace from 93 with range 1 to
    private void appendMappingTo(
        Mapping m, Appendable out) throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000010000000000000000000000000000000000000000000000000000000000
pattern: 10000001000000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 7
replace from 96 with range 1 to
      String sourceFile = m.sourceFile;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000001000000000000000000000000000000000000000000000000000000000
pattern: 10000000100000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 8
insert before 98 with       String escapedSourceFile;
      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
      }
      escapedSourceFile = lastSourceFileEscaped;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000100000000000000000000000000000000000000000000000000000000
pattern: 10000000010000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 9
insert before 99 with       out.append(escapedSourceFile);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000010000000000000000000000000000000000000000000000000000000
pattern: 10000000001000000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 10
insert before 101 with       int line = m.originalPosition.getLineNumber();
      if (line != lastLine) {
        lastLineString = String.valueOf(line);
      }
      String lineValue = lastLineString;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000001000000000000000000000000000000000000000000000000000000
pattern: 10000000000100000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 11
replace from 102 with range 1 to
      out.append(lineValue);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000100000000000000000000000000000000000000000000000000000
pattern: 10000000000010000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 12
replace from 105 with range 1 to
      out.append(String.valueOf(
          m.originalPosition.getCharacterIndex()));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000010000000000000000000000000000000000000000000000000000
pattern: 10000000000001000000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 13
replace from 107 with range 1 to
      if (m.originalName != null) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000001000000000000000000000000000000000000000000000000000
pattern: 10000000000000100000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 14
replace from 109 with range 1 to
        out.append(escapeString(m.originalName));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000100000000000000000000000000000000000000000000000000
pattern: 10000000000000010000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 15
replace from 112 with range 1 to
      out.append("]\n");

patches are written to file
running tests...
used time: Finished in 125.94 seconds
Failing tests: 9
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 10000000000000010000000000000000000000000000000000000000000000000
pattern: 10000000000000001000000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 16
insert before 114 with 

patches are written to file
running tests...
used time: Finished in 125.64 seconds
Failing tests: 5
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Can independently fix []
Could not fix independently
processed: 10000000000000001000000000000000000000000000000000000000000000000
pattern: 10000000000000000100000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 17
insert before 117 with     void appendMappings(Appendable out) throws IOException {
      for (Mapping m : mappings) {
        if (m.used) {
          appendMappingTo(m, out);
        }
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000100000000000000000000000000000000000000000000000
pattern: 10000000000000000010000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 18
delete from 143 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000010000000000000000000000000000000000000000000000
pattern: 10000000000000000001000000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 19
delete from 163 with range 6
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000001000000000000000000000000000000000000000000000
pattern: 10000000000000000000100000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 20
replace from 171 with range 2 to
    mapping.sourceFile = sourceFile;

patches are written to file
running tests...
used time: Finished in 120.04 seconds
Failing tests: 9
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 10000000000000000000100000000000000000000000000000000000000000000
pattern: 10000000000000000000010000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 21
replace from 177 with range 1 to
      mapping.originalName = originalName;

patches are written to file
running tests...
used time: Finished in 124.54 seconds
Failing tests: 5
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Can independently fix []
Could not fix independently
processed: 10000000000000000000010000000000000000000000000000000000000000000
pattern: 10000000000000000000001000000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 22
insert before 180 with     if (offsetPosition.getLineNumber() == 0
        && offsetPosition.getCharacterIndex() == 0) {
      mapping.startPosition = startPosition;
      mapping.endPosition = endPosition;
    } else {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000001000000000000000000000000000000000000000000
pattern: 10000000000000000000000100000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 23
insert before 203 with     }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000100000000000000000000000000000000000000000
pattern: 10000000000000000000000010000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 24
delete from 257 with range 8
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000010000000000000000000000000000000000000000
pattern: 10000000000000000000000001000000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 25
replace from 304 with range 1 to
    int maxLine = prepMappings();

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000001000000000000000000000000000000000000000
pattern: 10000000000000000000000000100000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 26
replace from 326 with range 4 to
    (new MappingWriter()).appendMappings(out);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000100000000000000000000000000000000000000
pattern: 10000000000000000000000000010000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 27
insert before 335 with   private int prepMappings() throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000010000000000000000000000000000000000000
pattern: 10000000000000000000000000001000000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 28
insert before 336 with     (new MappingTraversal()).traverse(new UsedMappingCheck());

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000001000000000000000000000000000000000000
pattern: 10000000000000000000000000000100000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 29
insert before 338 with     int id = 0;
    int maxLine = 0;
    for (Mapping m : mappings) {
      if (m.used) {
        m.id = id++;
        int endPositionLine = m.endPosition.getLineNumber();
        maxLine = Math.max(maxLine, endPositionLine);
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000100000000000000000000000000000000000
pattern: 10000000000000000000000000000010000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 30
insert before 340 with     return maxLine + prefixPosition.getLineNumber();
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000010000000000000000000000000000000000
pattern: 10000000000000000000000000000001000000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 31
replace from 341 with range 1 to
  private class LineMapper implements MappingVisitor {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000001000000000000000000000000000000000
pattern: 10000000000000000000000000000000100000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 32
replace from 344 with range 2 to


patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000100000000000000000000000000000000
pattern: 10000000000000000000000000000000010000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 33
replace from 351 with range 1 to
    private int lastId = UNMAPPED;
    private String lastIdString = UNMAPPED_STRING;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000010000000000000000000000000000000
pattern: 10000000000000000000000000000000001000000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 34
insert before 360 with     public void visit(Mapping m, int line, int col, int nextLine, int nextCol)
      throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000001000000000000000000000000000000
pattern: 10000000000000000000000000000000000100000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 35
insert before 361 with       int id = (m != null) ? m.id : UNMAPPED;
      if (lastId != id) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000100000000000000000000000000000
pattern: 10000000000000000000000000000000000010000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 36
insert before 363 with         lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);
        lastId = id;
      }
      String idString = lastIdString;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000010000000000000000000000000000
pattern: 10000000000000000000000000000000000001000000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 37
insert before 364 with       for (int i = line; i <= nextLine; i++) {
        if (i == nextLine) {
          for (int j = col; j < nextCol; j++) {
            addCharEntry(idString);
          }
          break;
        }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000001000000000000000000000000000
pattern: 10000000000000000000000000000000000000100000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 38
insert before 365 with         closeLine();
        openLine();
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000100000000000000000000000000
pattern: 10000000000000000000000000000000000000010000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 39
insert before 373 with       (new MappingTraversal()).traverse(this);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000010000000000000000000000000
pattern: 10000000000000000000000000000000000000001000000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 40
insert before 375 with       closeLine();
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000001000000000000000000000000
pattern: 10000000000000000000000000000000000000000100000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 41
insert before 379 with     private void openLine() throws IOException {
      if (out != null) {
        out.append("[");
        this.firstChar = true;
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000100000000000000000000000
pattern: 10000000000000000000000000000000000000000010000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 42
insert before 383 with     private void closeLine() throws IOException {
      if (out != null) {
        out.append("]\n");
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000010000000000000000000000
pattern: 10000000000000000000000000000000000000000001000000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 43
insert before 388 with     private void addCharEntry(String id) throws IOException {
      if (out != null) {
        if (firstChar) {
          firstChar = false;
        } else {
          out.append(",");
        }
        out.append(id);
      }
    }
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000001000000000000000000000
pattern: 10000000000000000000000000000000000000000000100000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 44
insert before 392 with   private class UsedMappingCheck implements MappingVisitor {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000100000000000000000000
pattern: 10000000000000000000000000000000000000000000010000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 45
insert before 395 with     @Override
    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)
        throws IOException {
      if (m != null) {
        m.used = true;
      }
    }
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000010000000000000000000
pattern: 10000000000000000000000000000000000000000000001000000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 46
insert before 396 with   private interface MappingVisitor {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000001000000000000000000
pattern: 10000000000000000000000000000000000000000000000100000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 47
insert before 405 with     void visit(Mapping m, int line, int col, int endLine, int endCol)
        throws IOException;
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000100000000000000000
pattern: 10000000000000000000000000000000000000000000000010000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 48
insert before 410 with   private class MappingTraversal {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000010000000000000000
pattern: 10000000000000000000000000000000000000000000000001000000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 49
insert before 411 with     private int line;
    private int col;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000001000000000000000
pattern: 10000000000000000000000000000000000000000000000000100000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 50
insert before 412 with     MappingTraversal() {
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000100000000000000
pattern: 10000000000000000000000000000000000000000000000000010000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 51
insert before 414 with     void traverse(MappingVisitor v) throws IOException {
      Preconditions.checkState(!mappings.isEmpty());

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000010000000000000
pattern: 10000000000000000000000000000000000000000000000000001000000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 52
replace from 426 with range 1 to
          maybeVisit(v, previous);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000001000000000000
pattern: 10000000000000000000000000000000000000000000000000000100000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 53
replace from 432 with range 1 to
        maybeVisitParent(v, parent, m);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000100000000000
pattern: 10000000000000000000000000000000000000000000000000000010000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 54
replace from 441 with range 16 to
        maybeVisit(v, m);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000010000000000
pattern: 10000000000000000000000000000000000000000000000000000001000000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 55
delete from 458 with range 1
patches are written to file
running tests...
used time: Finished in 139.62 seconds
Failing tests: 9
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 10000000000000000000000000000000000000000000000000000001000000000
pattern: 10000000000000000000000000000000000000000000000000000000100000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 56
replace from 496 with range 1 to
    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000000100000000
pattern: 10000000000000000000000000000000000000000000000000000000010000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 57
replace from 502 with range 1 to
        visit(v, m, nextLine, nextCol);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000000010000000
pattern: 10000000000000000000000000000000000000000000000000000000001000000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 58
replace from 509 with range 1 to
    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000000001000000
pattern: 10000000000000000000000000000000000000000000000000000000000100000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 59
replace from 511 with range 2 to
      int nextLine = getAdjustedLine(m.startPosition);
      int nextCol = getAdjustedCol(m.startPosition);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000000000100000
pattern: 10000000000000000000000000000000000000000000000000000000000010000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 60
replace from 514 with range 2 to
      Preconditions.checkState(line < nextLine || col <= nextCol);
      if (line < nextLine || (line == nextLine && col < nextCol)) {
        visit(v, parent, nextLine, nextCol);
      }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000000000010000
pattern: 10000000000000000000000000000000000000000000000000000000000001000
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 61
replace from 522 with range 2 to
    private void visit(MappingVisitor v, Mapping m,
        int nextLine, int nextCol)

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000000000001000
pattern: 10000000000000000000000000000000000000000000000000000000000000100
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 62
replace from 525 with range 2 to
      Preconditions.checkState(line <= nextLine);
      Preconditions.checkState(line < nextLine || col < nextCol);

patches are written to file
running tests...
used time: Finished in 122.73 seconds
Failing tests: 10
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicDeterminism
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 10000000000000000000000000000000000000000000000000000000000000100
pattern: 10000000000000000000000000000000000000000000000000000000000000010
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 63
insert before 530 with         Preconditions.checkState(false);

patches are written to file
running tests...
used time: Finished in 128.68 seconds
Failing tests: 10
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicDeterminism
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 10000000000000000000000000000000000000000000000000000000000000010
pattern: 10000000000000000000000000000000000000000000000000000000000000001
try to fix hunk: 0
insert before 182 with       case Token.VOID:
        typeNameString = "undefined";
        break;

try to fix hunk: 64
replace from 533 with range 11 to
      v.visit(m, line, col, nextLine, nextCol);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10000000000000000000000000000000000000000000000000000000000000001
pattern: 01100000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 2
replace from 50 with range 1 to
    int id = UNMAPPED;

patches are written to file
running tests...
used time: Finished in 126.85 seconds
Failing tests: 5
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Can independently fix ['com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6']
select new bug
Pattern: 01100000000000000000000000000000000000000000000000000000000000000
new failing tests:
com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
Save found bug
processed: 01100000000000000000000000000000000000000000000000000000000000000
pattern: 01010000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 3
insert before 85 with     boolean used = false;
  }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010000000000000000000000000000000000000000000000000000000000000
pattern: 01001000000000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 4
insert before 86 with   private class MappingWriter {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001000000000000000000000000000000000000000000000000000000000000
pattern: 01000100000000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 5
insert before 89 with     private String lastSourceFile = null;
    private String lastSourceFileEscaped = null;
    private int lastLine = 0;
    private String lastLineString = String.valueOf(0);

patches are written to file
running tests...
used time: Finished in 131.85 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Can independently fix []
Could not fix independently
processed: 01000100000000000000000000000000000000000000000000000000000000000
pattern: 01000010000000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 6
replace from 93 with range 1 to
    private void appendMappingTo(
        Mapping m, Appendable out) throws IOException {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000010000000000000000000000000000000000000000000000000000000000
pattern: 01000001000000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 7
replace from 96 with range 1 to
      String sourceFile = m.sourceFile;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000001000000000000000000000000000000000000000000000000000000000
pattern: 01000000100000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 8
insert before 98 with       String escapedSourceFile;
      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)
        lastSourceFile = sourceFile;
        lastSourceFileEscaped = escapeString(sourceFile);
      }
      escapedSourceFile = lastSourceFileEscaped;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000100000000000000000000000000000000000000000000000000000000
pattern: 01000000010000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 9
insert before 99 with       out.append(escapedSourceFile);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000010000000000000000000000000000000000000000000000000000000
pattern: 01000000001000000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 10
insert before 101 with       int line = m.originalPosition.getLineNumber();
      if (line != lastLine) {
        lastLineString = String.valueOf(line);
      }
      String lineValue = lastLineString;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000001000000000000000000000000000000000000000000000000000000
pattern: 01000000000100000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 11
replace from 102 with range 1 to
      out.append(lineValue);

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000100000000000000000000000000000000000000000000000000000
pattern: 01000000000010000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 12
replace from 105 with range 1 to
      out.append(String.valueOf(
          m.originalPosition.getCharacterIndex()));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000010000000000000000000000000000000000000000000000000000
pattern: 01000000000001000000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 13
replace from 107 with range 1 to
      if (m.originalName != null) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000001000000000000000000000000000000000000000000000000000
pattern: 01000000000000100000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 14
replace from 109 with range 1 to
        out.append(escapeString(m.originalName));

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000000100000000000000000000000000000000000000000000000000
pattern: 01000000000000010000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 15
replace from 112 with range 1 to
      out.append("]\n");

patches are written to file
running tests...
used time: Finished in 128.30 seconds
Failing tests: 10
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 01000000000000010000000000000000000000000000000000000000000000000
pattern: 01000000000000001000000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 16
insert before 114 with 

patches are written to file
running tests...
used time: Finished in 132.21 seconds
Failing tests: 6
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Can independently fix []
Could not fix independently
processed: 01000000000000001000000000000000000000000000000000000000000000000
pattern: 01000000000000000100000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 17
insert before 117 with     void appendMappings(Appendable out) throws IOException {
      for (Mapping m : mappings) {
        if (m.used) {
          appendMappingTo(m, out);
        }
      }
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000000000100000000000000000000000000000000000000000000000
pattern: 01000000000000000010000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 18
delete from 143 with range 2
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000000000010000000000000000000000000000000000000000000000
pattern: 01000000000000000001000000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 19
delete from 163 with range 6
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000000000000000001000000000000000000000000000000000000000000000
pattern: 01000000000000000000100000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 20
replace from 171 with range 2 to
    mapping.sourceFile = sourceFile;

patches are written to file
running tests...
used time: Finished in 144.43 seconds
Failing tests: 10
	com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof$catena_6
	com.google.javascript.jscomp.SourceMapTest::testMultilineMapping
	com.google.javascript.jscomp.SourceMapTest::testMultiFunctionMapping
	com.google.javascript.jscomp.SourceMapTest::testBasicMapping
	com.google.javascript.jscomp.SourceMapTest::testLiteralMappings
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput0
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput1
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput2
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput3
	com.google.javascript.jscomp.SourceMapTest::testGoldenOutput4
Includes new failing tests, set to unusable
processed: 01000000000000000000100000000000000000000000000000000000000000000
pattern: 01000000000000000000010000000000000000000000000000000000000000000
try to fix hunk: 1
insert before 41 with   private final static int UNMAPPED = -1;

try to fix hunk: 21
replace from 177 with range 1 to
      mapping.originalName = originalName;

patches are written to file
running tests...
EXCEPTION: Inside Exception generator.run() timeout
Traceback (most recent call last):
  File "run.py", line 30, in task
    generator.run()
  File "/root/workbench/CatenaD4j/scripts/generateBugs/timeout_decorator/timeout_decorator.py", line 82, in new_function
    return function(*args, **kwargs)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/runner.py", line 83, in run
    self._run()
  File "/root/workbench/CatenaD4j/scripts/generateBugs/runner.py", line 109, in _run
    self.taskSingleHunk(task)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/runner.py", line 138, in taskSingleHunk
    failure = util.get_failing_tests(self.path, self.build_dir)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/util.py", line 46, in get_failing_tests
    result = runCommand(['defects4j', 'test', '-w', '{}'.format(path)], timeout=timeout)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/util.py", line 9, in runCommand
    finished = subprocess.run(cmd, capture_output=True, cwd=cwd, timeout=timeout)
  File "/usr/lib/python3.8/subprocess.py", line 495, in run
    stdout, stderr = process.communicate(input, timeout=timeout)
  File "/usr/lib/python3.8/subprocess.py", line 1028, in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
  File "/usr/lib/python3.8/subprocess.py", line 1868, in _communicate
    ready = selector.select(timeout)
  File "/usr/lib/python3.8/selectors.py", line 415, in select
    fd_event_list = self._selector.poll(timeout)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/timeout_decorator/timeout_decorator.py", line 69, in handler
    _raise_exception(timeout_exception, exception_message)
  File "/root/workbench/CatenaD4j/scripts/generateBugs/timeout_decorator/timeout_decorator.py", line 47, in _raise_exception
    raise exception(exception_message)
TimeoutError: generator.run() timeout

