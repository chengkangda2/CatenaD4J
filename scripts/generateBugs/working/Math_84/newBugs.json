{
    "original": {
        "num_of_hunks": 3,
        "0": {
            "file_name": "src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java",
            "replaced_with": "        final RealConvergenceChecker checker = getConvergenceChecker();\n",
            "patch_type": "insert",
            "next_line_no": 64
        },
        "1": {
            "file_name": "src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java",
            "replaced_with": "                return;\n            }\n",
            "patch_type": "insert",
            "next_line_no": 92
        },
        "2": {
            "file_name": "src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java",
            "replaced_with": "            final int iter = getIterations();\n            boolean converged = true;\n            for (int i = 0; i < simplex.length; ++i) {\n                converged &= checker.converged(iter, original[i], simplex[i]);\n            }\n            if (converged) {\n",
            "patch_type": "insert",
            "next_line_no": 94
        }
    },
    "method": {
        "failing_tests": [
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize",
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMath283"
        ],
        "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize": {
            "file_path": "src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java",
            "Instance": "Begin: Pos(69, 3)\nEnd: Pos(128, 3)\nSource: /root/workbench/exportInfo/d4j_buggy/Math_84/src/test/java//org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\nName: testMinimizeMaximize\nChilds: [StatementAssertion<Begin: Pos(99, 7), End: Pos(99, 68)>,\nStatementAssertion<Begin: Pos(100, 7), End: Pos(100, 68)>,\nStatementAssertion<Begin: Pos(101, 7), End: Pos(101, 69)>,\nStatementAssertion<Begin: Pos(102, 7), End: Pos(102, 58)>,\nStatementAssertion<Begin: Pos(103, 7), End: Pos(103, 58)>,\nStatementAssertion<Begin: Pos(106, 7), End: Pos(106, 68)>,\nStatementAssertion<Begin: Pos(107, 7), End: Pos(107, 68)>,\nStatementAssertion<Begin: Pos(108, 7), End: Pos(108, 69)>,\nStatementAssertion<Begin: Pos(109, 7), End: Pos(109, 58)>,\nStatementAssertion<Begin: Pos(110, 7), End: Pos(110, 58)>,\nStatementAssertion<Begin: Pos(114, 7), End: Pos(114, 68)>,\nStatementAssertion<Begin: Pos(115, 7), End: Pos(115, 68)>,\nStatementAssertion<Begin: Pos(116, 7), End: Pos(116, 69)>,\nStatementAssertion<Begin: Pos(117, 7), End: Pos(117, 58)>,\nStatementAssertion<Begin: Pos(118, 7), End: Pos(118, 58)>,\nStatementAssertion<Begin: Pos(122, 7), End: Pos(122, 68)>,\nStatementAssertion<Begin: Pos(123, 7), End: Pos(123, 68)>,\nStatementAssertion<Begin: Pos(124, 7), End: Pos(124, 69)>,\nStatementAssertion<Begin: Pos(125, 7), End: Pos(125, 58)>,\nStatementAssertion<Begin: Pos(126, 7), End: Pos(126, 58)>,\n]",
            "source": "/root/workbench/exportInfo/d4j_buggy/Math_84/src/test/java//org/apache/commons/math/optimization/direct/MultiDirectionalTest.java",
            "name": "testMinimizeMaximize",
            "begin": "Pos(69, 3)",
            "end": "Pos(128, 3)",
            "begin_line_no": 69,
            "end_line_no": 128,
            "child": [
                "Begin: Pos(99, 7)\nEnd: Pos(99, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(100, 7)\nEnd: Pos(100, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(101, 7)\nEnd: Pos(101, 69)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(102, 7)\nEnd: Pos(102, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(103, 7)\nEnd: Pos(103, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(106, 7)\nEnd: Pos(106, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(107, 7)\nEnd: Pos(107, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(108, 7)\nEnd: Pos(108, 69)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(109, 7)\nEnd: Pos(109, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(110, 7)\nEnd: Pos(110, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(114, 7)\nEnd: Pos(114, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(115, 7)\nEnd: Pos(115, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(116, 7)\nEnd: Pos(116, 69)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(117, 7)\nEnd: Pos(117, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(118, 7)\nEnd: Pos(118, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(122, 7)\nEnd: Pos(122, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(123, 7)\nEnd: Pos(123, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(124, 7)\nEnd: Pos(124, 69)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(125, 7)\nEnd: Pos(125, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(126, 7)\nEnd: Pos(126, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "  @Test\n  public void testMinimizeMaximize$catena_0()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_1()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_2()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                       /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_3()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() > 120);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_4()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_5()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_6()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_7()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                         /***** ORIGINAL ASSERTION IS HERE *****/              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_8()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      Assert.assertTrue(optimizer.getEvaluations() > 120);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_9()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_10()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_11()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_12()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                       /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_13()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() > 120);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_14()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_15()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_16()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_17()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                       /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_18()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() > 180);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "  @Test\n  public void testMinimizeMaximize$catena_19()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 220);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n  }"
            ],
            "func": {
                "0": "  @Test\n  public void testMinimizeMaximize$catena_0()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "1": "  @Test\n  public void testMinimizeMaximize$catena_1()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "2": "  @Test\n  public void testMinimizeMaximize$catena_2()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                       /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "3": "  @Test\n  public void testMinimizeMaximize$catena_3()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() > 120);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "4": "  @Test\n  public void testMinimizeMaximize$catena_4()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "5": "  @Test\n  public void testMinimizeMaximize$catena_5()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "6": "  @Test\n  public void testMinimizeMaximize$catena_6()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "7": "  @Test\n  public void testMinimizeMaximize$catena_7()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                         /***** ORIGINAL ASSERTION IS HERE *****/              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "8": "  @Test\n  public void testMinimizeMaximize$catena_8()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      Assert.assertTrue(optimizer.getEvaluations() > 120);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "9": "  @Test\n  public void testMinimizeMaximize$catena_9()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "10": "  @Test\n  public void testMinimizeMaximize$catena_10()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "11": "  @Test\n  public void testMinimizeMaximize$catena_11()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "12": "  @Test\n  public void testMinimizeMaximize$catena_12()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                       /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "13": "  @Test\n  public void testMinimizeMaximize$catena_13()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() > 120);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "14": "  @Test\n  public void testMinimizeMaximize$catena_14()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 150);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "15": "  @Test\n  public void testMinimizeMaximize$catena_15()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "16": "  @Test\n  public void testMinimizeMaximize$catena_16()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                        /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "17": "  @Test\n  public void testMinimizeMaximize$catena_17()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                       /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "18": "  @Test\n  public void testMinimizeMaximize$catena_18()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() > 180);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 220);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n  }",
                "19": "  @Test\n  public void testMinimizeMaximize$catena_19()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    }catch(Throwable __SHOULD_BE_IGNORED){}              \n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      try{ Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 120);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() < 150);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      try{ Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertTrue(optimizer.getEvaluations() > 180);                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertTrue(optimizer.getEvaluations() < 220);                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n  }"
            }
        },
        "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMath283": {
            "file_path": "src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java",
            "Instance": "Begin: Pos(192, 3)\nEnd: Pos(217, 3)\nSource: /root/workbench/exportInfo/d4j_buggy/Math_84/src/test/java//org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\nName: testMath283\nChilds: [StatementAssertion<Begin: Pos(210, 7), End: Pos(210, 67)>,\nStatementAssertion<Begin: Pos(214, 7), End: Pos(214, 76)>,\nStatementAssertion<Begin: Pos(215, 7), End: Pos(215, 76)>,\n]",
            "source": "/root/workbench/exportInfo/d4j_buggy/Math_84/src/test/java//org/apache/commons/math/optimization/direct/MultiDirectionalTest.java",
            "name": "testMath283",
            "begin": "Pos(192, 3)",
            "end": "Pos(217, 3)",
            "begin_line_no": 192,
            "end_line_no": 217,
            "child": [
                "Begin: Pos(210, 7)\nEnd: Pos(210, 67)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(214, 7)\nEnd: Pos(214, 76)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(215, 7)\nEnd: Pos(215, 76)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "  @Test\n  public void testMath283$catena_0()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      try{ Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      \n  }",
                "  @Test\n  public void testMath283$catena_1()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      try{ Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                                /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      \n  }",
                "  @Test\n  public void testMath283$catena_2()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      try{ Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      try{ Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                                /***** ORIGINAL ASSERTION IS HERE *****/\n      \n  }"
            ],
            "func": {
                "0": "  @Test\n  public void testMath283$catena_0()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                         /***** ORIGINAL ASSERTION IS HERE *****/\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      try{ Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      try{ Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      \n  }",
                "1": "  @Test\n  public void testMath283$catena_1()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      try{ Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                                /***** ORIGINAL ASSERTION IS HERE *****/\n      try{ Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      \n  }",
                "2": "  @Test\n  public void testMath283$catena_2()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      try{ Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      try{ Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );                           }catch(Throwable __SHOULD_BE_IGNORED){}\n      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );                                /***** ORIGINAL ASSERTION IS HERE *****/\n      \n  }"
            }
        }
    },
    "111": {
        "failing_tests": [
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize$catena_9",
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMath283$catena_0",
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize$catena_5",
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMath283$catena_2",
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize$catena_4",
            "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMath283$catena_1"
        ]
    }
}