---
Begin generate bug_id: Closure_141
num_of_hunks: 5
use working dir: ./working/data/Closure_141
Try to checkout Closure_141
build dir: ['./working/data/Closure_141/build/classes', './working/data/Closure_141/build/test']
init FileManager
trace file: src/com/google/javascript/jscomp/NodeUtil.java
trace file: src/com/google/javascript/jscomp/NodeUtil.java
trace file: src/com/google/javascript/jscomp/PureFunctionIdentifier.java
trace file: src/com/google/javascript/jscomp/PureFunctionIdentifier.java
trace file: src/com/google/javascript/jscomp/PureFunctionIdentifier.java
trying to replace old failing tests
edit: replace from 63 range 25 at test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
to
  public void testCanExposeExpression2$catena_0() {
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_1() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_2() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_3() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_4() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_5() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_6() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   /***** ORIGINAL ASSERTION IS HERE *****/

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_7() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_8() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_9() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_10() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   /***** ORIGINAL ASSERTION IS HERE *****/
  }
trace file: test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
new test num: 11
ori test num: 7
pattern: 00000
patches are written to file
running tests...
used time: Finished in 132.29 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
pattern: 00001
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 00010
try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
used time: Finished in 118.80 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
No new failing tests but only 1 hunk
pattern: 00100
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 01000
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 10000
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

patches are written to file
running tests...
used time: Finished in 124.68 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
No new failing tests but only 1 hunk
pattern: 00011
try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 00101
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 122.39 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix ['com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH']
select new bug
Pattern: 00101
failing tests: com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects@com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects@com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG@com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook@com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
pattern: 00110
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 01001
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 01010
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 01100
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 10001
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 10010
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
used time: Finished in 125.63 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
Can independently fix []
Could not fix independently
pattern: 10100
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 11000
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

patches are written to file
running tests...
used time: Finished in 124.33 seconds
Failing tests: 5
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
Can independently fix ['com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7', 'com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10', 'com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall']
select new bug
Pattern: 11000
failing tests: com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7@com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10@com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
pattern: 00111
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 120.20 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix []
Could not fix independently
pattern: 01011
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 01101
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 01110
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 10011
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 10101
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 123.00 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix []
Could not fix independently
pattern: 10110
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 11001
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 11010
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
used time: Finished in 117.46 seconds
Failing tests: 5
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
Can independently fix []
Could not fix independently
pattern: 11100
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 01111
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 10111
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 127.90 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix []
Could not fix independently
pattern: 11011
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 11101
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 125.07 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
pattern: 11110
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
pattern: 11111
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 125.50 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
Find 2 new bugs
