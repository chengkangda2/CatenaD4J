---
Begin generate bug_id: Closure_141
num_of_hunks: 5
timeout for running: 3600
use working dir: ./working/data/Closure_141
Try to checkout Closure_141
build dir: ['./working/data/Closure_141/build/classes', './working/data/Closure_141/build/test']
init FileManager
trace file: src/com/google/javascript/jscomp/NodeUtil.java
trace file: src/com/google/javascript/jscomp/PureFunctionIdentifier.java
trying to replace old failing tests
edit: replace from 63 range 25 at test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
to
  public void testCanExposeExpression2$catena_0() {
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_1() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_2() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_3() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_4() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_5() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_6() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   /***** ORIGINAL ASSERTION IS HERE *****/

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_7() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_8() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_9() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testCanExposeExpression2$catena_10() {
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "foo()", "foo");                                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo()", "foo");                                                     }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "var x = foo()", "foo");                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "if(foo()){}", "foo");                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "switch(foo()){}", "foo");                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "function (){ return foo();}", "foo");                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() && 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() || 1", "foo");                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ helperCanExposeExpression(
        DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo");                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    helperCanExposeExpression(
        DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo");                                   /***** ORIGINAL ASSERTION IS HERE *****/
  }
trace file: test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java
new test num: 11
ori test num: 7
pattern: 00000
patches are written to file
running tests...
used time: Finished in 133.58 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
processed: 00000
pattern: 00001
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00001
pattern: 00010
try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
used time: Finished in 111.52 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
No new failing tests but only 1 hunk
processed: 00010
pattern: 00100
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00100
pattern: 01000
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01000
pattern: 10000
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

patches are written to file
running tests...
used time: Finished in 111.93 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
No new failing tests but only 1 hunk
processed: 10000
pattern: 00011
try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00011
pattern: 00101
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 118.82 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix ['com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH', 'com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects']
select new bug
Pattern: 00101
new failing tests:
com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
Save found bug
processed: 00101
pattern: 00110
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 00110
pattern: 01001
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01001
pattern: 01010
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01010
pattern: 01100
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01100
pattern: 10001
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10001
pattern: 10010
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
used time: Finished in 110.78 seconds
Failing tests: 8
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
Can independently fix []
Could not fix independently
processed: 10010
pattern: 10100
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10100
pattern: 11000
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

patches are written to file
running tests...
used time: Finished in 116.19 seconds
Failing tests: 5
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
Can independently fix ['com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7', 'com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10', 'com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall']
select new bug
Pattern: 11000
new failing tests:
com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Save found bug
processed: 11000
pattern: 00111
try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 110.83 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix []
Could not fix independently
processed: 00111
pattern: 01011
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01011
pattern: 01101
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01101
pattern: 01110
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01110
pattern: 10011
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10011
pattern: 10101
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 112.91 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix []
Could not fix independently
processed: 10101
pattern: 10110
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 10110
pattern: 11001
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11001
pattern: 11010
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
used time: Finished in 112.08 seconds
Failing tests: 5
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHookWithSideEffects
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionForGorH
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrG
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGViaHook
	com.google.javascript.jscomp.PureFunctionIdentifierTest::testCallFunctionFOrGWithSideEffects
Can independently fix []
Could not fix independently
processed: 11010
pattern: 11100
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11100
pattern: 01111
try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 01111
pattern: 10111
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 108.42 seconds
Failing tests: 3
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression7
	com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2$catena_10
	com.google.javascript.jscomp.InlineFunctionsTest::testDecomposeAnonymousInCall
Can independently fix []
Could not fix independently
processed: 10111
pattern: 11011
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11011
pattern: 11101
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 109.63 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 11101
pattern: 11110
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
patches are written to file
running tests...
seems testing failed, see output:
<OUTPUT>
<Common Compile Failed>
<ENDOUTPUT>
processed: 11110
pattern: 11111
try to fix hunk: 0
insert before 602 with       case Token.FUNCTION:

try to fix hunk: 1
insert before 604 with         Preconditions.checkState(NodeUtil.isAnonymousFunction(n));
        return false;

try to fix hunk: 2
insert before 177 with     if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {

try to fix hunk: 3
delete from 179 with range 3
try to fix hunk: 4
insert before 198 with     } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else {
      return null;
    }

patches are written to file
running tests...
used time: Finished in 121.42 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 11111
Find 2 new bugs
