{
    "original": {
        "num_of_hunks": 2,
        "0": {
            "file_name": "src/com/google/javascript/jscomp/NodeUtil.java",
            "replaced_with": "      case Token.DELPROP:\n",
            "patch_type": "insert",
            "next_line_no": 1262
        },
        "1": {
            "file_name": "src/com/google/javascript/jscomp/NodeUtil.java",
            "replaced_with": "      case Token.DELPROP:\n",
            "patch_type": "insert",
            "next_line_no": 2910
        }
    },
    "method": {
        "failing_tests": [
            "com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult",
            "com.google.javascript.jscomp.NodeUtilTest::testLocalValue1"
        ],
        "com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult": {
            "file_path": "test/com/google/javascript/jscomp/NodeUtilTest.java",
            "Instance": "Begin: Pos(1467, 10)\nEnd: Pos(1517, 3)\nSource: /root/workbench/exportInfo/d4j_buggy/Closure_80/test//com/google/javascript/jscomp/NodeUtilTest.java\nName: testIsBooleanResult\nChilds: [StatementAssertion<Begin: Pos(1468, 5), End: Pos(1468, 56)>,\nStatementAssertion<Begin: Pos(1469, 5), End: Pos(1469, 58)>,\nStatementAssertion<Begin: Pos(1470, 5), End: Pos(1470, 60)>,\nStatementAssertion<Begin: Pos(1471, 5), End: Pos(1471, 57)>,\nStatementAssertion<Begin: Pos(1472, 5), End: Pos(1472, 57)>,\nStatementAssertion<Begin: Pos(1473, 5), End: Pos(1473, 64)>,\nStatementAssertion<Begin: Pos(1474, 5), End: Pos(1474, 63)>,\nStatementAssertion<Begin: Pos(1475, 5), End: Pos(1475, 58)>,\nStatementAssertion<Begin: Pos(1476, 5), End: Pos(1476, 64)>,\nStatementAssertion<Begin: Pos(1477, 5), End: Pos(1477, 61)>,\nStatementAssertion<Begin: Pos(1479, 5), End: Pos(1479, 61)>,\nStatementAssertion<Begin: Pos(1480, 5), End: Pos(1480, 61)>,\nStatementAssertion<Begin: Pos(1481, 5), End: Pos(1481, 62)>,\nStatementAssertion<Begin: Pos(1483, 5), End: Pos(1483, 60)>,\nStatementAssertion<Begin: Pos(1484, 5), End: Pos(1484, 60)>,\nStatementAssertion<Begin: Pos(1485, 5), End: Pos(1485, 61)>,\nStatementAssertion<Begin: Pos(1486, 5), End: Pos(1486, 61)>,\nStatementAssertion<Begin: Pos(1487, 5), End: Pos(1487, 59)>,\nStatementAssertion<Begin: Pos(1488, 5), End: Pos(1488, 59)>,\nStatementAssertion<Begin: Pos(1489, 5), End: Pos(1489, 60)>,\nStatementAssertion<Begin: Pos(1490, 5), End: Pos(1490, 60)>,\nStatementAssertion<Begin: Pos(1491, 5), End: Pos(1491, 60)>,\nStatementAssertion<Begin: Pos(1492, 5), End: Pos(1492, 68)>,\nStatementAssertion<Begin: Pos(1494, 5), End: Pos(1494, 58)>,\nStatementAssertion<Begin: Pos(1495, 5), End: Pos(1495, 60)>,\nStatementAssertion<Begin: Pos(1496, 5), End: Pos(1496, 60)>,\nStatementAssertion<Begin: Pos(1497, 5), End: Pos(1497, 58)>,\nStatementAssertion<Begin: Pos(1498, 5), End: Pos(1498, 58)>,\nStatementAssertion<Begin: Pos(1499, 5), End: Pos(1499, 59)>,\nStatementAssertion<Begin: Pos(1500, 5), End: Pos(1500, 58)>,\nStatementAssertion<Begin: Pos(1501, 5), End: Pos(1501, 60)>,\nStatementAssertion<Begin: Pos(1502, 5), End: Pos(1502, 62)>,\nStatementAssertion<Begin: Pos(1503, 5), End: Pos(1503, 62)>,\nStatementAssertion<Begin: Pos(1504, 5), End: Pos(1504, 62)>,\nStatementAssertion<Begin: Pos(1507, 5), End: Pos(1507, 69)>,\nStatementAssertion<Begin: Pos(1508, 5), End: Pos(1508, 65)>,\nStatementAssertion<Begin: Pos(1511, 5), End: Pos(1511, 67)>,\nStatementAssertion<Begin: Pos(1512, 5), End: Pos(1512, 67)>,\nStatementAssertion<Begin: Pos(1513, 5), End: Pos(1513, 70)>,\nStatementAssertion<Begin: Pos(1514, 5), End: Pos(1514, 60)>,\nStatementAssertion<Begin: Pos(1515, 5), End: Pos(1515, 60)>,\nStatementAssertion<Begin: Pos(1516, 5), End: Pos(1516, 58)>,\n]",
            "source": "/root/workbench/exportInfo/d4j_buggy/Closure_80/test//com/google/javascript/jscomp/NodeUtilTest.java",
            "name": "testIsBooleanResult",
            "begin": "Pos(1467, 10)",
            "end": "Pos(1517, 3)",
            "begin_line_no": 1467,
            "end_line_no": 1517,
            "child": [
                "Begin: Pos(1468, 5)\nEnd: Pos(1468, 56)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1469, 5)\nEnd: Pos(1469, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1470, 5)\nEnd: Pos(1470, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1471, 5)\nEnd: Pos(1471, 57)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1472, 5)\nEnd: Pos(1472, 57)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1473, 5)\nEnd: Pos(1473, 64)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1474, 5)\nEnd: Pos(1474, 63)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1475, 5)\nEnd: Pos(1475, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1476, 5)\nEnd: Pos(1476, 64)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1477, 5)\nEnd: Pos(1477, 61)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1479, 5)\nEnd: Pos(1479, 61)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1480, 5)\nEnd: Pos(1480, 61)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1481, 5)\nEnd: Pos(1481, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1483, 5)\nEnd: Pos(1483, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1484, 5)\nEnd: Pos(1484, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1485, 5)\nEnd: Pos(1485, 61)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1486, 5)\nEnd: Pos(1486, 61)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1487, 5)\nEnd: Pos(1487, 59)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1488, 5)\nEnd: Pos(1488, 59)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1489, 5)\nEnd: Pos(1489, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1490, 5)\nEnd: Pos(1490, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1491, 5)\nEnd: Pos(1491, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1492, 5)\nEnd: Pos(1492, 68)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1494, 5)\nEnd: Pos(1494, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1495, 5)\nEnd: Pos(1495, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1496, 5)\nEnd: Pos(1496, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1497, 5)\nEnd: Pos(1497, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1498, 5)\nEnd: Pos(1498, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1499, 5)\nEnd: Pos(1499, 59)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1500, 5)\nEnd: Pos(1500, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1501, 5)\nEnd: Pos(1501, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1502, 5)\nEnd: Pos(1502, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1503, 5)\nEnd: Pos(1503, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1504, 5)\nEnd: Pos(1504, 62)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1507, 5)\nEnd: Pos(1507, 69)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1508, 5)\nEnd: Pos(1508, 65)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1511, 5)\nEnd: Pos(1511, 67)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1512, 5)\nEnd: Pos(1512, 67)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1513, 5)\nEnd: Pos(1513, 70)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1514, 5)\nEnd: Pos(1514, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1515, 5)\nEnd: Pos(1515, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1516, 5)\nEnd: Pos(1516, 58)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "  public void testIsBooleanResult$catena_0() {\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_1() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_2() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_3() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_4() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_5() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_6() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_7() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_8() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_9() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_10() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_11() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_12() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_13() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_14() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_15() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_16() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_17() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_18() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_19() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_20() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_21() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_22() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_23() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_24() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_25() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_26() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_27() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_28() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_29() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_30() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_31() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_32() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_33() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_34() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_35() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                           /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_36() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_37() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_38() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_39() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_40() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testIsBooleanResult$catena_41() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
            ],
            "func": {
                "0": "  public void testIsBooleanResult$catena_0() {\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "1": "  public void testIsBooleanResult$catena_1() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "2": "  public void testIsBooleanResult$catena_2() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "3": "  public void testIsBooleanResult$catena_3() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "4": "  public void testIsBooleanResult$catena_4() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "5": "  public void testIsBooleanResult$catena_5() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "6": "  public void testIsBooleanResult$catena_6() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "7": "  public void testIsBooleanResult$catena_7() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "8": "  public void testIsBooleanResult$catena_8() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "9": "  public void testIsBooleanResult$catena_9() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "10": "  public void testIsBooleanResult$catena_10() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "11": "  public void testIsBooleanResult$catena_11() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "12": "  public void testIsBooleanResult$catena_12() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "13": "  public void testIsBooleanResult$catena_13() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "14": "  public void testIsBooleanResult$catena_14() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "15": "  public void testIsBooleanResult$catena_15() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "16": "  public void testIsBooleanResult$catena_16() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                               /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "17": "  public void testIsBooleanResult$catena_17() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "18": "  public void testIsBooleanResult$catena_18() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "19": "  public void testIsBooleanResult$catena_19() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "20": "  public void testIsBooleanResult$catena_20() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "21": "  public void testIsBooleanResult$catena_21() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "22": "  public void testIsBooleanResult$catena_22() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                        /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "23": "  public void testIsBooleanResult$catena_23() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "24": "  public void testIsBooleanResult$catena_24() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "25": "  public void testIsBooleanResult$catena_25() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "26": "  public void testIsBooleanResult$catena_26() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "27": "  public void testIsBooleanResult$catena_27() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "28": "  public void testIsBooleanResult$catena_28() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "29": "  public void testIsBooleanResult$catena_29() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "30": "  public void testIsBooleanResult$catena_30() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "31": "  public void testIsBooleanResult$catena_31() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "32": "  public void testIsBooleanResult$catena_32() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "33": "  public void testIsBooleanResult$catena_33() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "34": "  public void testIsBooleanResult$catena_34() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "35": "  public void testIsBooleanResult$catena_35() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                           /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "36": "  public void testIsBooleanResult$catena_36() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "37": "  public void testIsBooleanResult$catena_37() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                         /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "38": "  public void testIsBooleanResult$catena_38() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "39": "  public void testIsBooleanResult$catena_39() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "40": "  public void testIsBooleanResult$catena_40() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "41": "  public void testIsBooleanResult$catena_41() {\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"+1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-1\")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"-Infinity\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"Infinity\")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >> b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a >>> b\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a == b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a != b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a === b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a !== b\")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a < b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a > b\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a <= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a >= b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a in b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a instanceof b\")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"'a'+b\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+'b'\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a+b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a()\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"''.a\")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b\")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Definitely not boolean\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true && false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"true || false\")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a,true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(NodeUtil.isBooleanResult(getNode(\"a=true\")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
            }
        },
        "com.google.javascript.jscomp.NodeUtilTest::testLocalValue1": {
            "file_path": "test/com/google/javascript/jscomp/NodeUtilTest.java",
            "Instance": "Begin: Pos(1073, 10)\nEnd: Pos(1170, 3)\nSource: /root/workbench/exportInfo/d4j_buggy/Closure_80/test//com/google/javascript/jscomp/NodeUtilTest.java\nName: testLocalValue1\nChilds: [StatementAssertion<Begin: Pos(1075, 5), End: Pos(1075, 37)>,\nStatementAssertion<Begin: Pos(1076, 5), End: Pos(1076, 39)>,\nStatementAssertion<Begin: Pos(1077, 5), End: Pos(1077, 40)>,\nStatementAssertion<Begin: Pos(1078, 5), End: Pos(1078, 45)>,\nStatementAssertion<Begin: Pos(1082, 5), End: Pos(1082, 43)>,\nStatementAssertion<Begin: Pos(1085, 5), End: Pos(1085, 47)>,\nStatementAssertion<Begin: Pos(1086, 5), End: Pos(1086, 50)>,\nStatementAssertion<Begin: Pos(1089, 5), End: Pos(1089, 39)>,\nStatementAssertion<Begin: Pos(1090, 5), End: Pos(1090, 44)>,\nStatementAssertion<Begin: Pos(1091, 5), End: Pos(1091, 43)>,\nStatementAssertion<Begin: Pos(1092, 5), End: Pos(1092, 38)>,\nStatementAssertion<Begin: Pos(1093, 5), End: Pos(1093, 36)>,\nStatementAssertion<Begin: Pos(1094, 5), End: Pos(1094, 38)>,\nStatementAssertion<Begin: Pos(1095, 5), End: Pos(1095, 39)>,\nStatementAssertion<Begin: Pos(1096, 5), End: Pos(1096, 40)>,\nStatementAssertion<Begin: Pos(1097, 5), End: Pos(1097, 37)>,\nStatementAssertion<Begin: Pos(1098, 5), End: Pos(1098, 37)>,\nStatementAssertion<Begin: Pos(1101, 5), End: Pos(1101, 38)>,\nStatementAssertion<Begin: Pos(1102, 5), End: Pos(1102, 42)>,\nStatementAssertion<Begin: Pos(1105, 5), End: Pos(1105, 38)>,\nStatementAssertion<Begin: Pos(1106, 5), End: Pos(1106, 38)>,\nStatementAssertion<Begin: Pos(1109, 5), End: Pos(1109, 39)>,\nStatementAssertion<Begin: Pos(1110, 5), End: Pos(1110, 39)>,\nStatementAssertion<Begin: Pos(1113, 5), End: Pos(1113, 38)>,\nStatementAssertion<Begin: Pos(1114, 5), End: Pos(1114, 40)>,\nStatementAssertion<Begin: Pos(1115, 5), End: Pos(1115, 39)>,\nStatementAssertion<Begin: Pos(1118, 5), End: Pos(1118, 39)>,\nStatementAssertion<Begin: Pos(1119, 5), End: Pos(1119, 39)>,\nStatementAssertion<Begin: Pos(1122, 5), End: Pos(1122, 39)>,\nStatementAssertion<Begin: Pos(1123, 5), End: Pos(1123, 39)>,\nStatementAssertion<Begin: Pos(1124, 5), End: Pos(1124, 38)>,\nStatementAssertion<Begin: Pos(1126, 5), End: Pos(1126, 40)>,\nStatementAssertion<Begin: Pos(1127, 5), End: Pos(1127, 40)>,\nStatementAssertion<Begin: Pos(1128, 5), End: Pos(1128, 41)>,\nStatementAssertion<Begin: Pos(1131, 5), End: Pos(1131, 39)>,\nStatementAssertion<Begin: Pos(1132, 5), End: Pos(1132, 40)>,\nStatementAssertion<Begin: Pos(1133, 5), End: Pos(1133, 40)>,\nStatementAssertion<Begin: Pos(1134, 5), End: Pos(1134, 40)>,\nStatementAssertion<Begin: Pos(1137, 5), End: Pos(1137, 39)>,\nStatementAssertion<Begin: Pos(1138, 5), End: Pos(1138, 40)>,\nStatementAssertion<Begin: Pos(1139, 5), End: Pos(1139, 40)>,\nStatementAssertion<Begin: Pos(1140, 5), End: Pos(1140, 40)>,\nStatementAssertion<Begin: Pos(1143, 5), End: Pos(1143, 40)>,\nStatementAssertion<Begin: Pos(1144, 5), End: Pos(1144, 41)>,\nStatementAssertion<Begin: Pos(1145, 5), End: Pos(1145, 41)>,\nStatementAssertion<Begin: Pos(1146, 5), End: Pos(1146, 41)>,\nStatementAssertion<Begin: Pos(1149, 5), End: Pos(1149, 37)>,\nStatementAssertion<Begin: Pos(1150, 5), End: Pos(1150, 37)>,\nStatementAssertion<Begin: Pos(1151, 5), End: Pos(1151, 40)>,\nStatementAssertion<Begin: Pos(1152, 5), End: Pos(1152, 40)>,\nStatementAssertion<Begin: Pos(1153, 5), End: Pos(1153, 40)>,\nStatementAssertion<Begin: Pos(1155, 5), End: Pos(1155, 43)>,\nStatementAssertion<Begin: Pos(1156, 5), End: Pos(1156, 43)>,\nStatementAssertion<Begin: Pos(1157, 5), End: Pos(1157, 49)>,\nStatementAssertion<Begin: Pos(1159, 5), End: Pos(1159, 41)>,\nStatementAssertion<Begin: Pos(1160, 5), End: Pos(1160, 41)>,\nStatementAssertion<Begin: Pos(1162, 5), End: Pos(1162, 40)>,\nStatementAssertion<Begin: Pos(1164, 5), End: Pos(1164, 48)>,\nStatementAssertion<Begin: Pos(1165, 5), End: Pos(1165, 47)>,\nStatementAssertion<Begin: Pos(1167, 5), End: Pos(1167, 47)>,\nStatementAssertion<Begin: Pos(1169, 5), End: Pos(1169, 45)>,\n]",
            "source": "/root/workbench/exportInfo/d4j_buggy/Closure_80/test//com/google/javascript/jscomp/NodeUtilTest.java",
            "name": "testLocalValue1",
            "begin": "Pos(1073, 10)",
            "end": "Pos(1170, 3)",
            "begin_line_no": 1073,
            "end_line_no": 1170,
            "child": [
                "Begin: Pos(1075, 5)\nEnd: Pos(1075, 37)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1076, 5)\nEnd: Pos(1076, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1077, 5)\nEnd: Pos(1077, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1078, 5)\nEnd: Pos(1078, 45)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1082, 5)\nEnd: Pos(1082, 43)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1085, 5)\nEnd: Pos(1085, 47)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1086, 5)\nEnd: Pos(1086, 50)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1089, 5)\nEnd: Pos(1089, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1090, 5)\nEnd: Pos(1090, 44)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1091, 5)\nEnd: Pos(1091, 43)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1092, 5)\nEnd: Pos(1092, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1093, 5)\nEnd: Pos(1093, 36)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1094, 5)\nEnd: Pos(1094, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1095, 5)\nEnd: Pos(1095, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1096, 5)\nEnd: Pos(1096, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1097, 5)\nEnd: Pos(1097, 37)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1098, 5)\nEnd: Pos(1098, 37)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1101, 5)\nEnd: Pos(1101, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1102, 5)\nEnd: Pos(1102, 42)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1105, 5)\nEnd: Pos(1105, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1106, 5)\nEnd: Pos(1106, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1109, 5)\nEnd: Pos(1109, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1110, 5)\nEnd: Pos(1110, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1113, 5)\nEnd: Pos(1113, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1114, 5)\nEnd: Pos(1114, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1115, 5)\nEnd: Pos(1115, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1118, 5)\nEnd: Pos(1118, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1119, 5)\nEnd: Pos(1119, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1122, 5)\nEnd: Pos(1122, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1123, 5)\nEnd: Pos(1123, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1124, 5)\nEnd: Pos(1124, 38)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1126, 5)\nEnd: Pos(1126, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1127, 5)\nEnd: Pos(1127, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1128, 5)\nEnd: Pos(1128, 41)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1131, 5)\nEnd: Pos(1131, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1132, 5)\nEnd: Pos(1132, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1133, 5)\nEnd: Pos(1133, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1134, 5)\nEnd: Pos(1134, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1137, 5)\nEnd: Pos(1137, 39)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1138, 5)\nEnd: Pos(1138, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1139, 5)\nEnd: Pos(1139, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1140, 5)\nEnd: Pos(1140, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1143, 5)\nEnd: Pos(1143, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1144, 5)\nEnd: Pos(1144, 41)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1145, 5)\nEnd: Pos(1145, 41)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1146, 5)\nEnd: Pos(1146, 41)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1149, 5)\nEnd: Pos(1149, 37)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1150, 5)\nEnd: Pos(1150, 37)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1151, 5)\nEnd: Pos(1151, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1152, 5)\nEnd: Pos(1152, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1153, 5)\nEnd: Pos(1153, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1155, 5)\nEnd: Pos(1155, 43)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1156, 5)\nEnd: Pos(1156, 43)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1157, 5)\nEnd: Pos(1157, 49)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1159, 5)\nEnd: Pos(1159, 41)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1160, 5)\nEnd: Pos(1160, 41)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1162, 5)\nEnd: Pos(1162, 40)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1164, 5)\nEnd: Pos(1164, 48)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1165, 5)\nEnd: Pos(1165, 47)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1167, 5)\nEnd: Pos(1167, 47)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(1169, 5)\nEnd: Pos(1169, 45)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "  public void testLocalValue1$catena_0() throws Exception {\n    // Names are not known to be local.\n    assertFalse(testLocalValue(\"x\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_1() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x()\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_2() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"this\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_3() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"arguments\"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_4() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    assertFalse(testLocalValue(\"new x()\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_5() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    assertFalse(testLocalValue(\"(new x()).y\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_6() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"(new x())['y']\"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_7() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    assertTrue(testLocalValue(\"null\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_8() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"undefined\"));                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_9() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"Infinity\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_10() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"NaN\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_11() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"1\"));                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_12() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"'a'\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_13() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"true\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_14() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"false\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_15() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"[]\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_16() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"{}\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_17() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    assertTrue(testLocalValue(\"[x]\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_18() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"{'a':x}\"));                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_19() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    assertTrue(testLocalValue(\"++x\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_20() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"--x\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_21() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    assertFalse(testLocalValue(\"x++\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_22() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x--\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_23() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    assertTrue(testLocalValue(\"x=1\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_24() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x=[]\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_25() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_26() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    assertTrue(testLocalValue(\"x+=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_27() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x*=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_28() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    assertTrue(testLocalValue(\"x==y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_29() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x!=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_30() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x>y\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_31() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    assertTrue(testLocalValue(\"(1,2)\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_32() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"(x,1)\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_33() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"(x,y)\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_34() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    assertTrue(testLocalValue(\"1||2\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_35() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x||1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_36() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x||y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_37() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"1||y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_38() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    assertTrue(testLocalValue(\"1&&2\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_39() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x&&1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_40() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x&&y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_41() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"1&&y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_42() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    assertTrue(testLocalValue(\"x?1:2\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_43() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?x:2\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_44() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?1:x\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_45() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?x:y\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_46() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    assertTrue(testLocalValue(\"!y\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_47() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"~y\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_48() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y + 1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_49() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y + z\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_50() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y * z\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_51() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"'a' in x\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_52() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"typeof x\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_53() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x instanceof y\"));                                                           /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_54() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"void x\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_55() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"void 0\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_56() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(testLocalValue(\"{}.x\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_57() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"{}.toString()\"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_58() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"o.toString()\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_59() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "  public void testLocalValue1$catena_60() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"delete a.b\"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
            ],
            "func": {
                "0": "  public void testLocalValue1$catena_0() throws Exception {\n    // Names are not known to be local.\n    assertFalse(testLocalValue(\"x\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "1": "  public void testLocalValue1$catena_1() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x()\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "2": "  public void testLocalValue1$catena_2() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"this\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "3": "  public void testLocalValue1$catena_3() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"arguments\"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "4": "  public void testLocalValue1$catena_4() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    assertFalse(testLocalValue(\"new x()\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "5": "  public void testLocalValue1$catena_5() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    assertFalse(testLocalValue(\"(new x()).y\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "6": "  public void testLocalValue1$catena_6() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"(new x())['y']\"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "7": "  public void testLocalValue1$catena_7() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    assertTrue(testLocalValue(\"null\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "8": "  public void testLocalValue1$catena_8() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"undefined\"));                                                                /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "9": "  public void testLocalValue1$catena_9() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"Infinity\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "10": "  public void testLocalValue1$catena_10() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"NaN\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "11": "  public void testLocalValue1$catena_11() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"1\"));                                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "12": "  public void testLocalValue1$catena_12() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"'a'\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "13": "  public void testLocalValue1$catena_13() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"true\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "14": "  public void testLocalValue1$catena_14() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"false\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "15": "  public void testLocalValue1$catena_15() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"[]\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "16": "  public void testLocalValue1$catena_16() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"{}\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "17": "  public void testLocalValue1$catena_17() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    assertTrue(testLocalValue(\"[x]\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "18": "  public void testLocalValue1$catena_18() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"{'a':x}\"));                                                                  /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "19": "  public void testLocalValue1$catena_19() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    assertTrue(testLocalValue(\"++x\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "20": "  public void testLocalValue1$catena_20() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"--x\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "21": "  public void testLocalValue1$catena_21() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    assertFalse(testLocalValue(\"x++\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "22": "  public void testLocalValue1$catena_22() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x--\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "23": "  public void testLocalValue1$catena_23() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    assertTrue(testLocalValue(\"x=1\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "24": "  public void testLocalValue1$catena_24() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x=[]\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "25": "  public void testLocalValue1$catena_25() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "26": "  public void testLocalValue1$catena_26() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    assertTrue(testLocalValue(\"x+=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "27": "  public void testLocalValue1$catena_27() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x*=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "28": "  public void testLocalValue1$catena_28() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    assertTrue(testLocalValue(\"x==y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "29": "  public void testLocalValue1$catena_29() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x!=y\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "30": "  public void testLocalValue1$catena_30() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x>y\"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "31": "  public void testLocalValue1$catena_31() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    assertTrue(testLocalValue(\"(1,2)\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "32": "  public void testLocalValue1$catena_32() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"(x,1)\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "33": "  public void testLocalValue1$catena_33() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"(x,y)\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "34": "  public void testLocalValue1$catena_34() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    assertTrue(testLocalValue(\"1||2\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "35": "  public void testLocalValue1$catena_35() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x||1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "36": "  public void testLocalValue1$catena_36() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x||y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "37": "  public void testLocalValue1$catena_37() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"1||y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "38": "  public void testLocalValue1$catena_38() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    assertTrue(testLocalValue(\"1&&2\"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "39": "  public void testLocalValue1$catena_39() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x&&1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "40": "  public void testLocalValue1$catena_40() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x&&y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "41": "  public void testLocalValue1$catena_41() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"1&&y\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "42": "  public void testLocalValue1$catena_42() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    assertTrue(testLocalValue(\"x?1:2\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "43": "  public void testLocalValue1$catena_43() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?x:2\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "44": "  public void testLocalValue1$catena_44() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?1:x\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "45": "  public void testLocalValue1$catena_45() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertFalse(testLocalValue(\"x?x:y\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "46": "  public void testLocalValue1$catena_46() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    assertTrue(testLocalValue(\"!y\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "47": "  public void testLocalValue1$catena_47() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"~y\"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "48": "  public void testLocalValue1$catena_48() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y + 1\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "49": "  public void testLocalValue1$catena_49() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y + z\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "50": "  public void testLocalValue1$catena_50() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"y * z\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "51": "  public void testLocalValue1$catena_51() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"'a' in x\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "52": "  public void testLocalValue1$catena_52() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"typeof x\"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "53": "  public void testLocalValue1$catena_53() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"x instanceof y\"));                                                           /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "54": "  public void testLocalValue1$catena_54() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"void x\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "55": "  public void testLocalValue1$catena_55() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"void 0\"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "56": "  public void testLocalValue1$catena_56() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(testLocalValue(\"{}.x\"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "57": "  public void testLocalValue1$catena_57() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"{}.toString()\"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "58": "  public void testLocalValue1$catena_58() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    assertTrue(testLocalValue(\"o.toString()\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "59": "  public void testLocalValue1$catena_59() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n\n    try{ assertTrue(testLocalValue(\"delete a.b\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n  }",
                "60": "  public void testLocalValue1$catena_60() throws Exception {\n    // Names are not known to be local.\n    try{ assertFalse(testLocalValue(\"x\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x()\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"this\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"arguments\"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    try{ assertFalse(testLocalValue(\"new x()\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // property references are assume to be non-local\n    try{ assertFalse(testLocalValue(\"(new x()).y\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(new x())['y']\"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Primitive values are local\n    try{ assertTrue(testLocalValue(\"null\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"undefined\"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"Infinity\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"NaN\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"1\"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"'a'\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"true\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"false\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"[]\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{}\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The contents of arrays and objects don't matter\n    try{ assertTrue(testLocalValue(\"[x]\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"{'a':x}\"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Pre-increment results in primitive number\n    try{ assertTrue(testLocalValue(\"++x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"--x\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Post-increment, the previous value matters.\n    try{ assertFalse(testLocalValue(\"x++\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x--\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // The left side of an only assign matters if it is an alias or mutable.\n    try{ assertTrue(testLocalValue(\"x=1\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=[]\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // The right hand side of assignment opts don't matter, as they force\n    // a local result.\n    try{ assertTrue(testLocalValue(\"x+=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x*=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Comparisons always result in locals, as they force a local boolean\n    // result.\n    try{ assertTrue(testLocalValue(\"x==y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x!=y\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x>y\"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}\n    // Only the right side of a comma matters\n    try{ assertTrue(testLocalValue(\"(1,2)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"(x,1)\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"(x,y)\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of OR matter\n    try{ assertTrue(testLocalValue(\"1||2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1||y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Both the operands of AND matter\n    try{ assertTrue(testLocalValue(\"1&&2\"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"1&&y\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Only the results of HOOK matter\n    try{ assertTrue(testLocalValue(\"x?1:2\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:2\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?1:x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertFalse(testLocalValue(\"x?x:y\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    // Results of ops are local values\n    try{ assertTrue(testLocalValue(\"!y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"~y\"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + 1\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y + z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"y * z\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"'a' in x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"typeof x\"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"x instanceof y\"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"void x\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"void 0\"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"{}.x\"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertTrue(testLocalValue(\"{}.toString()\"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n    try{ assertTrue(testLocalValue(\"o.toString()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    try{ assertFalse(testLocalValue(\"o.valueOf()\"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    assertTrue(testLocalValue(\"delete a.b\"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/\n  }"
            }
        }
    }
}