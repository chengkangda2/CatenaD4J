---
Begin generate bug_id: Closure_80
num_of_hunks: 2
timeout for running: 3600
use working dir: ./working/data/Closure_80
Try to checkout Closure_80
build dir: ['./working/data/Closure_80/build/classes', './working/data/Closure_80/build/test']
init FileManager
trace file: src/com/google/javascript/jscomp/NodeUtil.java
trying to replace old failing tests
edit: replace from 1467 range 51 at test/com/google/javascript/jscomp/NodeUtilTest.java
to
  public void testIsBooleanResult$catena_0() {
    assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_1() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_2() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_3() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_4() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_5() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_6() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_7() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_8() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_9() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                               /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_10() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_11() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_12() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                              /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_13() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_14() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_15() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_16() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                               /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_17() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_18() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_19() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_20() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_21() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_22() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                        /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_23() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_24() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_25() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_26() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_27() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_28() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_29() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_30() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_31() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_32() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                              /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_33() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                              /***** ORIGINAL ASSERTION IS HERE *****/

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_34() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_35() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                           /***** ORIGINAL ASSERTION IS HERE *****/

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_36() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_37() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                         /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_38() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_39() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_40() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testIsBooleanResult$catena_41() {
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("1")));                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("+1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-1")));                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("Infinity")));                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("NaN")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("undefined")));                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("void 0")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a << b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >> b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a == b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a != b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a === b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a !== b")));                                          }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a < b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a > b")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a <= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a >= b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a in b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b")));                                   }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a+b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a()")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("''.a")));                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b")));                                             }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a.b()")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("a().b()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("new a()")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("delete a")));                                         }catch(Throwable __SHOULD_BE_IGNORED){}

    // Definitely not boolean
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])")));                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})")));                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    // These are boolean but aren't handled yet, "false" here means "unknown".
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true && false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("true || false")));                                    }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false")));                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a,true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(NodeUtil.isBooleanResult(getNode("a=true")));                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(NodeUtil.isBooleanResult(getNode("a=1")));                                                  /***** ORIGINAL ASSERTION IS HERE *****/
  }
edit: replace from 1073 range 98 at test/com/google/javascript/jscomp/NodeUtilTest.java
to
  public void testLocalValue1$catena_0() throws Exception {
    // Names are not known to be local.
    assertFalse(testLocalValue("x"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_1() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x()"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_2() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("this"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_3() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("arguments"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_4() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    assertFalse(testLocalValue("new x()"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_5() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    assertFalse(testLocalValue("(new x()).y"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_6() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("(new x())['y']"));                                                          /***** ORIGINAL ASSERTION IS HERE *****/

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_7() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    assertTrue(testLocalValue("null"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_8() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("undefined"));                                                                /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_9() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("Infinity"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_10() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("NaN"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_11() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("1"));                                                                        /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_12() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("'a'"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_13() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("true"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_14() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("false"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_15() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("[]"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_16() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("{}"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_17() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    assertTrue(testLocalValue("[x]"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_18() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("{'a':x}"));                                                                  /***** ORIGINAL ASSERTION IS HERE *****/

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_19() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    assertTrue(testLocalValue("++x"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_20() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("--x"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_21() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    assertFalse(testLocalValue("x++"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_22() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x--"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_23() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    assertTrue(testLocalValue("x=1"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_24() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x=[]"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_25() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x=y"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_26() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    assertTrue(testLocalValue("x+=y"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_27() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("x*=y"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_28() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    assertTrue(testLocalValue("x==y"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_29() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("x!=y"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_30() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("x>y"));                                                                      /***** ORIGINAL ASSERTION IS HERE *****/
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_31() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    assertTrue(testLocalValue("(1,2)"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_32() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("(x,1)"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_33() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("(x,y)"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_34() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    assertTrue(testLocalValue("1||2"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_35() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x||1"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_36() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x||y"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_37() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("1||y"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_38() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    assertTrue(testLocalValue("1&&2"));                                                                     /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_39() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x&&1"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_40() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x&&y"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_41() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("1&&y"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_42() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    assertTrue(testLocalValue("x?1:2"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_43() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x?x:2"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_44() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x?1:x"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_45() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertFalse(testLocalValue("x?x:y"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_46() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    assertTrue(testLocalValue("!y"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_47() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("~y"));                                                                       /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_48() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("y + 1"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_49() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("y + z"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_50() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("y * z"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_51() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTrue(testLocalValue("'a' in x"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_52() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("typeof x"));                                                                 /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_53() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("x instanceof y"));                                                           /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_54() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTrue(testLocalValue("void x"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_55() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("void 0"));                                                                   /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_56() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    assertFalse(testLocalValue("{}.x"));                                                                    /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_57() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTrue(testLocalValue("{}.toString()"));                                                            /***** ORIGINAL ASSERTION IS HERE *****/
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_58() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    assertTrue(testLocalValue("o.toString()"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_59() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    assertFalse(testLocalValue("o.valueOf()"));                                                             /***** ORIGINAL ASSERTION IS HERE *****/

    try{ assertTrue(testLocalValue("delete a.b"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}
  }   public void testLocalValue1$catena_60() throws Exception {
    // Names are not known to be local.
    try{ assertFalse(testLocalValue("x"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x()"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("this"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("arguments"));                                                          }catch(Throwable __SHOULD_BE_IGNORED){}

    // We can't know if new objects are local unless we know
    // that they don't alias themselves.
    try{ assertFalse(testLocalValue("new x()"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}

    // property references are assume to be non-local
    try{ assertFalse(testLocalValue("(new x()).y"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(new x())['y']"));                                                     }catch(Throwable __SHOULD_BE_IGNORED){}

    // Primitive values are local
    try{ assertTrue(testLocalValue("null"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("undefined"));                                                           }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("Infinity"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("NaN"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("1"));                                                                   }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("'a'"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("true"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("false"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("[]"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{}"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}

    // The contents of arrays and objects don't matter
    try{ assertTrue(testLocalValue("[x]"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("{'a':x}"));                                                             }catch(Throwable __SHOULD_BE_IGNORED){}

    // Pre-increment results in primitive number
    try{ assertTrue(testLocalValue("++x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("--x"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}

    // Post-increment, the previous value matters.
    try{ assertFalse(testLocalValue("x++"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x--"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}

    // The left side of an only assign matters if it is an alias or mutable.
    try{ assertTrue(testLocalValue("x=1"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=[]"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // The right hand side of assignment opts don't matter, as they force
    // a local result.
    try{ assertTrue(testLocalValue("x+=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x*=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    // Comparisons always result in locals, as they force a local boolean
    // result.
    try{ assertTrue(testLocalValue("x==y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x!=y"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x>y"));                                                                 }catch(Throwable __SHOULD_BE_IGNORED){}
    // Only the right side of a comma matters
    try{ assertTrue(testLocalValue("(1,2)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("(x,1)"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("(x,y)"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of OR matter
    try{ assertTrue(testLocalValue("1||2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1||y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Both the operands of AND matter
    try{ assertTrue(testLocalValue("1&&2"));                                                                }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("1&&y"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    // Only the results of HOOK matter
    try{ assertTrue(testLocalValue("x?1:2"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:2"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?1:x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertFalse(testLocalValue("x?x:y"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    // Results of ops are local values
    try{ assertTrue(testLocalValue("!y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("~y"));                                                                  }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + 1"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y + z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("y * z"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("'a' in x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("typeof x"));                                                            }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("x instanceof y"));                                                      }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("void x"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("void 0"));                                                              }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("{}.x"));                                                               }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertTrue(testLocalValue("{}.toString()"));                                                       }catch(Throwable __SHOULD_BE_IGNORED){}
    try{ assertTrue(testLocalValue("o.toString()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    try{ assertFalse(testLocalValue("o.valueOf()"));                                                        }catch(Throwable __SHOULD_BE_IGNORED){}

    assertTrue(testLocalValue("delete a.b"));                                                               /***** ORIGINAL ASSERTION IS HERE *****/
  }
trace file: test/com/google/javascript/jscomp/NodeUtilTest.java
new test num: 103
ori test num: 0
pattern: 00
patches are written to file
running tests...
used time: Finished in 187.80 seconds
Failing tests: 2
	com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult$catena_33
	com.google.javascript.jscomp.NodeUtilTest::testLocalValue1$catena_60
processed: 00
pattern: 01
try to fix hunk: 1
insert before 2910 with       case Token.DELPROP:

patches are written to file
running tests...
used time: Finished in 175.72 seconds
Failing tests: 1
	com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult$catena_33
select new bug
Pattern: 01
new failing tests:
com.google.javascript.jscomp.NodeUtilTest::testLocalValue1$catena_60
Save found bug
processed: 01
pattern: 10
try to fix hunk: 0
insert before 1262 with       case Token.DELPROP:

patches are written to file
running tests...
used time: Finished in 169.04 seconds
Failing tests: 1
	com.google.javascript.jscomp.NodeUtilTest::testLocalValue1$catena_60
select new bug
Pattern: 10
new failing tests:
com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult$catena_33
Save found bug
processed: 10
pattern: 11
try to fix hunk: 0
insert before 1262 with       case Token.DELPROP:

try to fix hunk: 1
insert before 2910 with       case Token.DELPROP:

patches are written to file
running tests...
used time: Finished in 175.58 seconds
Failing tests: 0
Can independently fix []
Could not fix independently
processed: 11
Find 2 new bugs
