{
    "original": {
        "num_of_hunks": 2,
        "0": {
            "file_name": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
            "from_line_no": 240,
            "to_line_no": 245,
            "replaced_with": "        return Math.sqrt(getChiSquare() / rows);\n",
            "replaced": "        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += residual * residual * residualsWeights[i];\n        }\n        return Math.sqrt(criterion / rows);\n",
            "patch_type": "replace",
            "next_line_no": 246
        },
        "1": {
            "file_name": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
            "from_line_no": 258,
            "to_line_no": 258,
            "replaced_with": "            chiSquare += residual * residual * residualsWeights[i];\n",
            "replaced": "            chiSquare += residual * residual / residualsWeights[i];\n",
            "patch_type": "replace",
            "next_line_no": 259
        }
    },
    "method": {
        "failing_tests": [
            "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest::testCircleFitting"
        ],
        "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest::testCircleFitting": {
            "file_path": "src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java",
            "Instance": "Begin: Pos(398, 12)\nEnd: Pos(445, 5)\nSource: /root/workbench/exportInfo/d4j_buggy/Math_65/src/test/java//org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\nName: testCircleFitting\nChilds: [StatementAssertion<Begin: Pos(409, 9), End: Pos(409, 52)>,\nStatementAssertion<Begin: Pos(410, 9), End: Pos(410, 60)>,\nStatementAssertion<Begin: Pos(412, 9), End: Pos(412, 83)>,\nStatementAssertion<Begin: Pos(414, 9), End: Pos(414, 75)>,\nStatementAssertion<Begin: Pos(415, 9), End: Pos(415, 64)>,\nStatementAssertion<Begin: Pos(416, 9), End: Pos(416, 64)>,\nStatementAssertion<Begin: Pos(418, 9), End: Pos(418, 46)>,\nStatementAssertion<Begin: Pos(419, 9), End: Pos(419, 46)>,\nStatementAssertion<Begin: Pos(420, 9), End: Pos(420, 52)>,\nStatementAssertion<Begin: Pos(421, 9), End: Pos(421, 46)>,\nStatementAssertion<Begin: Pos(423, 9), End: Pos(423, 46)>,\nStatementAssertion<Begin: Pos(424, 9), End: Pos(424, 46)>,\nStatementAssertion<Begin: Pos(437, 9), End: Pos(437, 47)>,\nStatementAssertion<Begin: Pos(438, 9), End: Pos(438, 48)>,\nStatementAssertion<Begin: Pos(439, 9), End: Pos(439, 52)>,\nStatementAssertion<Begin: Pos(440, 9), End: Pos(440, 47)>,\nStatementAssertion<Begin: Pos(442, 9), End: Pos(442, 46)>,\nStatementAssertion<Begin: Pos(443, 9), End: Pos(443, 46)>,\n]",
            "source": "/root/workbench/exportInfo/d4j_buggy/Math_65/src/test/java//org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java",
            "name": "testCircleFitting",
            "begin": "Pos(398, 12)",
            "end": "Pos(445, 5)",
            "begin_line_no": 398,
            "end_line_no": 445,
            "child": [
                "Begin: Pos(409, 9)\nEnd: Pos(409, 52)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(410, 9)\nEnd: Pos(410, 60)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(412, 9)\nEnd: Pos(412, 83)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(414, 9)\nEnd: Pos(414, 75)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(415, 9)\nEnd: Pos(415, 64)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(416, 9)\nEnd: Pos(416, 64)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(418, 9)\nEnd: Pos(418, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(419, 9)\nEnd: Pos(419, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(420, 9)\nEnd: Pos(420, 52)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(421, 9)\nEnd: Pos(421, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(423, 9)\nEnd: Pos(423, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(424, 9)\nEnd: Pos(424, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(437, 9)\nEnd: Pos(437, 47)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(438, 9)\nEnd: Pos(438, 48)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(439, 9)\nEnd: Pos(439, 52)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(440, 9)\nEnd: Pos(440, 47)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(442, 9)\nEnd: Pos(442, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []",
                "Begin: Pos(443, 9)\nEnd: Pos(443, 46)\nSource: StatementExpression\nName: <Unknown>\nChilds: []"
            ],
            "splited": [
                "    public void testCircleFitting$catena_0() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        assertTrue(optimizer.getEvaluations() < 10);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_1() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertTrue(optimizer.getJacobianEvaluations() < 10);                                                /***** ORIGINAL ASSERTION IS HERE *****/\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_2() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                         /***** ORIGINAL ASSERTION IS HERE *****/\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_3() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                                 /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_4() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(96.07590211815305, center.x,      1.0e-10);                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_5() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(48.13516790438953, center.y,      1.0e-10);                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_6() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        assertEquals(1.839, cov[0][0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_7() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.731, cov[0][1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_8() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_9() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.786, cov[1][1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_10() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        assertEquals(1.384, errors[0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_11() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.905, errors[1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_12() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        assertEquals(0.0016, cov[0][0], 0.001);                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_13() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_14() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_15() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.0016, cov[1][1], 0.001);                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_16() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        assertEquals(0.004, errors[0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "    public void testCircleFitting$catena_17() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.004, errors[1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    }"
            ],
            "func": {
                "0": "    public void testCircleFitting$catena_0() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        assertTrue(optimizer.getEvaluations() < 10);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "1": "    public void testCircleFitting$catena_1() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertTrue(optimizer.getJacobianEvaluations() < 10);                                                /***** ORIGINAL ASSERTION IS HERE *****/\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "2": "    public void testCircleFitting$catena_2() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                         /***** ORIGINAL ASSERTION IS HERE *****/\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "3": "    public void testCircleFitting$catena_3() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                                 /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "4": "    public void testCircleFitting$catena_4() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(96.07590211815305, center.x,      1.0e-10);                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "5": "    public void testCircleFitting$catena_5() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(48.13516790438953, center.y,      1.0e-10);                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "6": "    public void testCircleFitting$catena_6() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        assertEquals(1.839, cov[0][0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "7": "    public void testCircleFitting$catena_7() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.731, cov[0][1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "8": "    public void testCircleFitting$catena_8() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "9": "    public void testCircleFitting$catena_9() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.786, cov[1][1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "10": "    public void testCircleFitting$catena_10() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        assertEquals(1.384, errors[0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "11": "    public void testCircleFitting$catena_11() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.905, errors[1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "12": "    public void testCircleFitting$catena_12() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        assertEquals(0.0016, cov[0][0], 0.001);                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "13": "    public void testCircleFitting$catena_13() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                            /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "14": "    public void testCircleFitting$catena_14() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                        /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "15": "    public void testCircleFitting$catena_15() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.0016, cov[1][1], 0.001);                                                             /***** ORIGINAL ASSERTION IS HERE *****/\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "16": "    public void testCircleFitting$catena_16() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        assertEquals(0.004, errors[0], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n        try{ assertEquals(0.004, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n    }",
                "17": "    public void testCircleFitting$catena_17() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        try{ assertTrue(optimizer.getEvaluations() < 10);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertTrue(optimizer.getJacobianEvaluations() < 10);                                           }catch(Throwable __SHOULD_BE_IGNORED){}\n        double rms = optimizer.getRMS();\n        try{ assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);                    }catch(Throwable __SHOULD_BE_IGNORED){}\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        try{ assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);                            }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(96.07590211815305, center.x,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(48.13516790438953, center.y,      1.0e-10);                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[][] cov = optimizer.getCovariances();\n        try{ assertEquals(1.839, cov[0][0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.731, cov[0][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.786, cov[1][1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        double[] errors = optimizer.guessParametersErrors();\n        try{ assertEquals(1.384, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.905, errors[1], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        try{ assertEquals(0.0016, cov[0][0], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(3.2e-7, cov[0][1], 1.0e-9);                                                       }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(cov[0][1], cov[1][0], 1.0e-14);                                                   }catch(Throwable __SHOULD_BE_IGNORED){}\n        try{ assertEquals(0.0016, cov[1][1], 0.001);                                                        }catch(Throwable __SHOULD_BE_IGNORED){}\n        errors = optimizer.guessParametersErrors();\n        try{ assertEquals(0.004, errors[0], 0.001);                                                         }catch(Throwable __SHOULD_BE_IGNORED){}\n        assertEquals(0.004, errors[1], 0.001);                                                              /***** ORIGINAL ASSERTION IS HERE *****/\n\n    }"
            }
        }
    }
}