Chart_22 hunk 3 code         
--------------------------------------------------
Chart_22 hunk 4 code         
--------------------------------------------------
Lang_23 hunk 2 code 
    /**
     * Return the hashcode.
     *
     * @return the hashcode
     */
--------------------------------------------------
Lang_64 hunk 2 code             // ignore - should never happen
--------------------------------------------------
Lang_64 hunk 3 code             // ignore - should never happen
--------------------------------------------------
Lang_64 hunk 4 code             // ignore - should never happen
--------------------------------------------------
Lang_41 hunk 1 code 
        // Handle array encoding
--------------------------------------------------
Lang_41 hunk 2 code             // Strip Object type encoding
--------------------------------------------------
Lang_41 hunk 3 code 
--------------------------------------------------
Lang_41 hunk 7 code         // Strip Object type encoding
--------------------------------------------------
Lang_65 hunk 1 code 
        // ----------------- Fix for LANG-59 ---------------------- START ---------------
        // see http://issues.apache.org/jira/browse/LANG-59
        //
        // Manually truncate milliseconds, seconds and minutes, rather than using
        // Calendar methods.

--------------------------------------------------
Lang_65 hunk 2 code 
        // truncate milliseconds
--------------------------------------------------
Lang_65 hunk 3 code 
        // truncate seconds
--------------------------------------------------
Lang_65 hunk 4 code 
        // truncate minutes
--------------------------------------------------
Lang_65 hunk 5 code 
        // reset time
--------------------------------------------------
Lang_37 hunk 2 code             // Check if problem is incompatible types
--------------------------------------------------
Lang_30 hunk 3 code                         // ch is a supplementary character
--------------------------------------------------
Lang_30 hunk 7 code                             // missing low surrogate, fine, like String.indexOf(String)
--------------------------------------------------
Lang_30 hunk 18 code                             // missing low surrogate, fine, like String.indexOf(String)
--------------------------------------------------
Lang_56 hunk 1 code     /**
     * The estimated maximum length.
     */
--------------------------------------------------
Lang_19 hunk 4 code 
--------------------------------------------------
Lang_7 hunk 2 code             // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
--------------------------------------------------
Lang_31 hunk 2 code 						// ch is a supplementary character
--------------------------------------------------
Lang_22 hunk 1 code         //if either operand is abs 1, return 1:
--------------------------------------------------
Math_3 hunk 1 code             // Revert to scalar multiplication.
--------------------------------------------------
Math_64 hunk 6 code 
                // determine the Levenberg-Marquardt parameter
--------------------------------------------------
Math_64 hunk 9 code 
                    // tests for convergence.
--------------------------------------------------
Math_64 hunk 10 code                     // we use the vectorial convergence checker
--------------------------------------------------
Math_90 hunk 1 code     
    /**
     * Adds 1 to the frequency count for v.
     * <p>
     * If other objects have already been added to this Frequency, v must
     * be comparable to those that have already been added.
     * </p>
     * 
     * @param v the value to add.
     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
     */
--------------------------------------------------
Math_88 hunk 2 code                 // if multiple variables can take a given value 
                // then we choose the first and set the rest equal to 0
--------------------------------------------------
Math_84 hunk 2 code 
            // check convergence
--------------------------------------------------
Math_78 hunk 1 code                         // this is a corner case:
                        // - there was an event near ta,
                        // - there is another event between ta and tb
                        // - when ta was computed, convergence was reached on the "wrong side" of the interval
                        // this implies that the real sign of ga is the same as gb, so we need to slightly
                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                        // about bracketing
--------------------------------------------------
Math_78 hunk 2 code                             // this should never happen
--------------------------------------------------
Math_97 hunk 1 code             // check if either value is close to a zero
--------------------------------------------------
Math_97 hunk 4 code             // either min or max is a root
--------------------------------------------------
Math_55 hunk 1 code 
      // rescale both vectors without losing precision,
      // to ensure their norm are the same order of magnitude
--------------------------------------------------
Math_55 hunk 2 code 
      // we reduce cancellation errors by preconditioning,
      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
      // v3 without loss of precision. See Kahan lecture
      // "Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces"
      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf

      // compute rho as an 8 bits approximation of v1.v2 / v2.v2
--------------------------------------------------
Math_55 hunk 3 code 
--------------------------------------------------
Math_55 hunk 4 code 
      // compute cross product from v3 and v2 instead of v1 and v2
--------------------------------------------------
Math_25 hunk 1 code                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                    // procedure cannot produce sensible results.
--------------------------------------------------
Math_42 hunk 1 code               // if the basic row is found to be the objective function row
              // set the coefficient to 0 -> this case handles unconstrained 
              // variables that are still part of the objective function
--------------------------------------------------
Math_106 hunk 1 code             // minus signs should be leading, invalid expression
--------------------------------------------------
Math_106 hunk 3 code             // minus signs must be leading, invalid
--------------------------------------------------
Math_51 hunk 1 code                         // Update formula cannot make any progress: Update the
                        // search interval.
--------------------------------------------------
Math_12 hunk 2 code     /** Serializable version identifier */
--------------------------------------------------
Math_36 hunk 1 code             // Numerator and/or denominator must be out of range:
            // Calculate how far to shift them to put them in range.
--------------------------------------------------
Math_36 hunk 3 code             // Numerator and/or denominator must be out of range:
            // Calculate how far to shift them to put them in range.
--------------------------------------------------
Math_68 hunk 6 code                     // we use the vectorial convergence checker
--------------------------------------------------
Math_16 hunk 2 code               // Avoid overflow (MATH-905).
--------------------------------------------------
Math_16 hunk 4 code               // Avoid overflow (MATH-905).
--------------------------------------------------
Math_16 hunk 7 code               // Avoid overflow (MATH-905).
--------------------------------------------------
Math_16 hunk 9 code               // Avoid overflow (MATH-905).
--------------------------------------------------
Math_92 hunk 1 code         // Use symmetry for large k
--------------------------------------------------
Math_92 hunk 2 code         
        // We use the formula
        // (n choose k) = n! / (n-k)! / k!
        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
        // which could be written
        // (n choose k) == (n-1 choose k-1) * n / k
--------------------------------------------------
Math_92 hunk 3 code             // For n <= 61, the naive implementation cannot overflow.
--------------------------------------------------
Math_92 hunk 4 code             // For n > 61 but n <= 66, the result cannot overflow,
            // but we must take care not to overflow intermediate values.
--------------------------------------------------
Math_92 hunk 5 code                 // We know that (result * i) is divisible by j,
                // but (result * i) may overflow, so we split j:
                // Filter out the gcd, d, so j/d and i/d are integer.
                // result is divisible by (j/d) because (j/d)
                // is relative prime to (i/d) and is a divisor of
                // result * (i/d).
--------------------------------------------------
Math_92 hunk 6 code             // For n > 66, a result overflow might occur, so we check
            // the multiplication, taking care to not overflow
            // unnecessary.
--------------------------------------------------
Math_92 hunk 8 code         
--------------------------------------------------
Math_92 hunk 9 code   
--------------------------------------------------
Math_92 hunk 11 code         
        /*
         * Return the log of binomialCoefficientDouble for values that will not
         * overflow binomialCoefficientDouble
         */
--------------------------------------------------
Math_28 hunk 2 code 
            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
--------------------------------------------------
Time_14 hunk 1 code             // month is largest field and being added to, such as month-day
--------------------------------------------------
Time_17 hunk 2 code         
        // calculate result
--------------------------------------------------
Time_17 hunk 3 code           // currently in later offset
--------------------------------------------------
Time_17 hunk 4 code           // currently in earlier offset
--------------------------------------------------
Time_12 hunk 3 code             // handle years in era BC
--------------------------------------------------
Time_12 hunk 7 code             // handle years in era BC
--------------------------------------------------
Time_22 hunk 1 code         // bug [3264409]
--------------------------------------------------
Closure_138 hunk 3 code         // There are two situations where we don't want to use type information
        // from the scope, even if we have it.

        // 1) The var is escaped in a weird way, e.g.,
        // function f() { var x = 3; function g() { x = null } (x); }
--------------------------------------------------
Closure_138 hunk 4 code 
        // 2) We're reading type information from another scope for an
        // inferred variable.
        // var t = null; function f() { (t); }
--------------------------------------------------
Closure_138 hunk 5 code 
--------------------------------------------------
Closure_157 hunk 3 code             // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
--------------------------------------------------
Closure_157 hunk 4 code                 // do not encode literally any non-literal characters that
                // were unicode escaped.
--------------------------------------------------
Closure_157 hunk 7 code 
--------------------------------------------------
Closure_157 hunk 11 code 
--------------------------------------------------
Closure_157 hunk 12 code 
    // Return "1" instead of "1.0"
--------------------------------------------------
Closure_110 hunk 5 code             // Replace "function NAME() { ... }" with "var NAME;".
--------------------------------------------------
Closure_110 hunk 6 code 
            // We can't keep the local name on the function expression,
            // because IE is buggy and will leak the name into the global
            // scope. This is covered in more detail here:
            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
            //
            // This will only cause problems if this is a hoisted, recursive
            // function, and the programmer is using the hoisting.
--------------------------------------------------
Closure_110 hunk 7 code 
--------------------------------------------------
Closure_110 hunk 8 code               // If this is a VAR, we can just detach the expression and
              // the tree will still be valid.
--------------------------------------------------
Closure_176 hunk 1 code 
        // When looking at VAR initializers for declared VARs, we tend
        // to use the declared type over the type it's being
        // initialized to in the global scope.
        //
        // For example,
        // /** @param {number} */ var f = goog.abstractMethod;
        // it's obvious that the programmer wants you to use
        // the declared function signature, not the inferred signature.
        //
        // Or,
        // /** @type {Object.<string>} */ var x = {};
        // the one-time anonymous object on the right side
        // is as narrow as it can possibly be, but we need to make
        // sure we back-infer the <string> element constraint on
        // the left hand side, so we use the left hand side.

--------------------------------------------------
Closure_176 hunk 2 code             // Makes it easier to check for NPEs.
--------------------------------------------------
Closure_165 hunk 4 code 
  /**
   * Creates a record type.
   *
   * @param registry The type registry under which this type lives.
   * @param properties A map of all the properties of this record type.
   * @param declared Whether this is a declared or synthesized type.
   *     A synthesized record type is just used for bookkeeping
   *     in the type system. A declared record type was actually used in the
   *     user's program.
   * @throws IllegalStateException if the {@code RecordProperty} associated
   *         with a property is null.
   */
--------------------------------------------------
Closure_88 hunk 1 code         // The expression to which the assignment is made is evaluated before
        // the RHS is evaluated (normal left to right evaluation) but the KILL
        // occurs after the RHS is evaluated.
--------------------------------------------------
Closure_175 hunk 5 code       // Limit the inlining
--------------------------------------------------
Closure_137 hunk 4 code 
    // Stack reference sets.
--------------------------------------------------
Closure_137 hunk 5 code 
    // Name are globally unique initially, so we don't need a per-scope map.
--------------------------------------------------
Closure_137 hunk 7 code 
    /**
     * Prepare a set for the new scope.
     */
--------------------------------------------------
Closure_137 hunk 8 code 
--------------------------------------------------
Closure_137 hunk 11 code 
      // Merge any names that were referenced but not declared in the current
      // scope.
--------------------------------------------------
Closure_137 hunk 12 code       // If there isn't anything left in the stack we will be going into the
      // global scope: don't try to build a set of referenced names for the
      // global scope.
--------------------------------------------------
Closure_137 hunk 13 code 
    /**
     * For the Var declared in the current scope determine if it is possible
     * to revert the name to its orginal form without conflicting with other
     * values.
     */
--------------------------------------------------
Closure_137 hunk 14 code         // Check if the new name is valid and if it would cause conflicts.
--------------------------------------------------
Closure_137 hunk 15 code           // Adding a reference to the new name to prevent either the parent
          // scopes or the current scope renaming another var to this new name.
--------------------------------------------------
Closure_137 hunk 17 code 
--------------------------------------------------
Closure_137 hunk 18 code 
--------------------------------------------------
Closure_137 hunk 20 code         // Add all referenced names to the set so it is possible to check for
        // conflicts.
--------------------------------------------------
Closure_137 hunk 21 code         // Store only references to candidate names in the node map.
--------------------------------------------------
Closure_162 hunk 3 code 
--------------------------------------------------
Closure_162 hunk 4 code             // TODO(robbyw): Support using locals for private variables.
--------------------------------------------------
Closure_162 hunk 6 code 
--------------------------------------------------
Closure_162 hunk 8 code 
--------------------------------------------------
Closure_174 hunk 2 code         // Most passes try to report as many errors as possible,
        // so there may already be errors. We only care if there were
        // errors in the code we just parsed.
--------------------------------------------------
Closure_37 hunk 2 code         // When in ideMode Rhino tries to parse some constructs the compiler
        // doesn't support, repair it here. see Rhino's
        // Parser#parseFunctionBodyExpr.
--------------------------------------------------
Closure_136 hunk 3 code           // Blindly de-uniquify for the Prototype library for issue 103.
--------------------------------------------------
Closure_134 hunk 8 code         // If it's not, then check to see if it's implemented
        // on an implemented interface.
--------------------------------------------------
Closure_98 hunk 2 code 
    /**
     * Whether this block denotes a loop.
     */
--------------------------------------------------
Closure_98 hunk 4 code 
--------------------------------------------------
Closure_163 hunk 2 code           // NOTE(nicksantos): We use the same anonymous node for all
          // functions that do not have reasonable names. I can't remember
          // at the moment why we do this. I think it's because anonymous
          // nodes can never have in-edges. They're just there as a placeholder
          // for scope information, and do not matter in the edge propagation.
--------------------------------------------------
Closure_163 hunk 10 code         // Make sure that we're not handling object literals being
        // assigned to a prototype, as in:
        // Foo.prototype = {bar: 3, baz: 5};
--------------------------------------------------
Closure_163 hunk 15 code 
--------------------------------------------------
Closure_163 hunk 17 code 
    /**
     * Returns the name of a prototype property being assigned to this r-value.
     *
     * Returns null if this is not the R-value of a prototype property, or if
     * the R-value is used in multiple expressions (i.e., if there's
     * a prototype property assignment in a more complex expression).
     */
--------------------------------------------------
Closure_163 hunk 18 code 
--------------------------------------------------
Closure_163 hunk 20 code 
--------------------------------------------------
Closure_163 hunk 25 code 
--------------------------------------------------
Closure_163 hunk 36 code 
--------------------------------------------------
Closure_163 hunk 41 code 
--------------------------------------------------
Closure_163 hunk 46 code 
--------------------------------------------------
Closure_163 hunk 48 code 
--------------------------------------------------
Closure_121 hunk 1 code           // Inlining the variable based solely on well-defined and assigned
          // once is *NOT* correct. We relax the correctness requirement if
          // the variable is declared constant.
--------------------------------------------------
Closure_48 hunk 1 code         // Determining declaration for #2
--------------------------------------------------
Closure_153 hunk 4 code         // We allow variables to be duplicate declared if one
        // declaration appears in source and the other in externs.
        // This deals with issues where a browser built-in is declared
        // in one browser but not in another.
--------------------------------------------------
Closure_153 hunk 16 code 
--------------------------------------------------
Closure_96 hunk 1 code       // If there are no parameters left in the list, then the while loop
      // above implies that this must be a var_args function.
--------------------------------------------------
Closure_42 hunk 1 code 
        // Return the bare minimum to put the AST in a valid state.
--------------------------------------------------
Closure_32 hunk 4 code               // All tokens must be separated by a space.
--------------------------------------------------
Closure_156 hunk 8 code 
--------------------------------------------------
Closure_169 hunk 3 code     // Please keep this method in sync with the hashCode() method below.
--------------------------------------------------
Closure_169 hunk 14 code         // If we're checking for invariance, the unknown type is invariant
        // with everyone.
--------------------------------------------------
Closure_103 hunk 2 code         // getGreatestSubtypeWithProperty does not guarantee that the property
        // is defined on the returned type, it just indicates that it might be,
        // so we have to double check.
--------------------------------------------------
Closure_17 hunk 1 code                 // If rValue has a type-cast, we use the type in the type-cast.
--------------------------------------------------
Closure_158 hunk 2 code 
    /**
     * Add warning guards.
     */
--------------------------------------------------
Closure_158 hunk 4 code 
    // The entries, in the order that they were added.
--------------------------------------------------
Closure_158 hunk 5 code 
--------------------------------------------------
Closure_158 hunk 6 code 
--------------------------------------------------
Closure_158 hunk 13 code 
--------------------------------------------------
Closure_158 hunk 14 code 
--------------------------------------------------
Closure_158 hunk 15 code 
--------------------------------------------------
Closure_158 hunk 16 code 
--------------------------------------------------
Closure_158 hunk 17 code 
--------------------------------------------------
Closure_158 hunk 18 code 
--------------------------------------------------
Closure_158 hunk 19 code 
--------------------------------------------------
Closure_154 hunk 6 code         // Implemented, but not correctly typed
--------------------------------------------------
Closure_76 hunk 7 code         // With a AND/OR the first branch always runs, but the second is
        // may not.
--------------------------------------------------
Closure_51 hunk 2 code 
--------------------------------------------------
Closure_164 hunk 1 code 
      // "that" can't be a supertype, because it's missing a required argument.
--------------------------------------------------
Closure_164 hunk 2 code         // NOTE(nicksantos): In our type system, we use {function(...?)} and
        // {function(...NoType)} to to indicate that arity should not be
        // checked. Strictly speaking, this is not a correct formulation,
        // because now a sub-function can required arguments that are var_args
        // in the super-function. So we special-case this.
--------------------------------------------------
Closure_145 hunk 1 code         // For labels with block children, we need to ensure that a
        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs 
        // are skipped. 
--------------------------------------------------
Closure_145 hunk 2 code           // Either a empty statement or an block with more than one child,
          // way it isn't a FUNCTION or DO.
--------------------------------------------------
Closure_2 hunk 1 code       // This can be the case if interfaceType is proxy to a non-existent
      // object (which is a bad type annotation, but shouldn't crash).
--------------------------------------------------
Closure_139 hunk 2 code 
    /**
     * Rewrite the function declaration from:
     *   function x() {}
     *   FUNCTION
     *     NAME
     *     LP
     *     BLOCK
     * to:
     *   var x = function() {};
     *   VAR
     *     NAME
     *       FUNCTION
     *         NAME (w/ empty string)
     *         LP
     *         BLOCK
     */
--------------------------------------------------
Closure_139 hunk 3 code       // Prepare a spot for the function.
--------------------------------------------------
Closure_139 hunk 4 code 
      // Prepare the function
--------------------------------------------------
Closure_139 hunk 5 code 
      // Move the function
--------------------------------------------------
Closure_139 hunk 6 code 
--------------------------------------------------
Closure_139 hunk 8 code       // If name is "arguments", Var maybe null.
--------------------------------------------------
Closure_19 hunk 1 code         // "this" references aren't currently modeled in the CFG.
--------------------------------------------------
Closure_170 hunk 1 code             // We make a special exception when the entire cfgNode is a chain
            // of assignments, since in that case the assignment statements
            // will happen after the inlining of the right hand side.
            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact
            //   and remove this special case.
--------------------------------------------------
Closure_170 hunk 2 code               // Don't count lhs of top-level assignment chain
--------------------------------------------------
Closure_50 hunk 2 code       // "," is the default, it doesn't need to be explicit
--------------------------------------------------
Closure_144 hunk 4 code 
--------------------------------------------------
Closure_101 hunk 1 code 
--------------------------------------------------
Closure_49 hunk 2 code 
--------------------------------------------------
Closure_49 hunk 3 code 
          // Add the function parameters
--------------------------------------------------
Closure_49 hunk 4 code 
          // Add the function body declarations
--------------------------------------------------
Closure_49 hunk 7 code         // Note: The parameters and function body variables live in the
        // same scope, we introduce the scope when in the "shouldTraverse"
        // visit of LP, but remove it when when we exit the function above.
--------------------------------------------------
Closure_155 hunk 3 code             // Any reference that is not a read of the arguments property
            // consider a escape of the arguments object.
--------------------------------------------------
Closure_155 hunk 4 code 
--------------------------------------------------
Closure_155 hunk 10 code         // TODO(johnlenz): provide the type of "Arguments".
--------------------------------------------------
Closure_155 hunk 11 code 
--------------------------------------------------
Closure_155 hunk 12 code 
--------------------------------------------------
Closure_155 hunk 13 code 
--------------------------------------------------
Closure_44 hunk 1 code       // Do not allow a forward slash to appear after a DIV.
      // For example,
      // REGEXP DIV REGEXP
      // is valid and should print like
      // / // / /
--------------------------------------------------
Closure_7 hunk 1 code           // Objects are restricted to "Function", subtypes are left
--------------------------------------------------
Closure_7 hunk 2 code           // Only filter out subtypes of "function"
--------------------------------------------------
Closure_66 hunk 1 code           // Object literal keys are not typeable
--------------------------------------------------
Closure_75 hunk 1 code       // vertical tab is not always whitespace
--------------------------------------------------
Closure_117 hunk 1 code 
    // The best type name is the actual type name.
--------------------------------------------------
Closure_54 hunk 4 code       // Disassociating the old prototype makes this easier to debug--
      // we don't have to worry about two prototypes running around.
--------------------------------------------------
Closure_148 hunk 4 code 
--------------------------------------------------
Closure_148 hunk 5 code     /**
     * Cache of escaped source file name.
     */
--------------------------------------------------
Closure_148 hunk 6 code 
    /**
     * Appends the mapping to the given buffer.
     */
--------------------------------------------------
Closure_148 hunk 8 code       // The source file rarely changes, so cache the escaped string.
--------------------------------------------------
Closure_148 hunk 9 code 
--------------------------------------------------
Closure_148 hunk 11 code 
--------------------------------------------------
Closure_148 hunk 13 code 
--------------------------------------------------
Closure_148 hunk 17 code     /**
     * Add used mappings to the supplied Appendable.
     */
--------------------------------------------------
Closure_148 hunk 28 code     // Mark any unused mappings.
--------------------------------------------------
Closure_148 hunk 29 code 
    // Renumber used mappings and keep track of the last line.
--------------------------------------------------
Closure_148 hunk 30 code 
    // Adjust for the prefix.
--------------------------------------------------
Closure_148 hunk 31 code 
--------------------------------------------------
Closure_148 hunk 35 code 
--------------------------------------------------
Closure_148 hunk 36 code         // Prevent the creation of unnecessary temporary stings for often
        // repeated values.
--------------------------------------------------
Closure_148 hunk 37 code 
--------------------------------------------------
Closure_148 hunk 38 code 
--------------------------------------------------
Closure_148 hunk 40 code 
      // And close the final line.
--------------------------------------------------
Closure_148 hunk 41 code 
    /**
     * Begin the entry for a new line.
     */
--------------------------------------------------
Closure_148 hunk 42 code 
    /**
     * End the entry for a line.
     */
--------------------------------------------------
Closure_148 hunk 43 code 
    /**
     * Add a new char position entry.
     * @param id The mapping id to record.
     */
--------------------------------------------------
Closure_148 hunk 44 code 
  /**
   * Mark any visited mapping as "used".
   */
--------------------------------------------------
Closure_148 hunk 45 code     /**
     * @throws IOException
     */
--------------------------------------------------
Closure_148 hunk 46 code 
--------------------------------------------------
Closure_148 hunk 47 code     /**
     * @param m The mapping for the current code segment. null if the segment
     *     is unmapped.
     * @param line The starting line for this code segment.
     * @param col The starting column for this code segment.
     * @param endLine The ending line
     * @param endCol The ending column
     * @throws IOException
     */
--------------------------------------------------
Closure_148 hunk 48 code 
  /**
   * Walk the mappings and visit each segment of the mappings, unmapped
   * segments are visited with a null mapping, unused mapping are not visited.
   */
--------------------------------------------------
Closure_148 hunk 49 code     // The last line and column written
--------------------------------------------------
Closure_148 hunk 50 code 
--------------------------------------------------
Closure_148 hunk 51 code 
    // Append the line mapping entries.
--------------------------------------------------
Closure_148 hunk 60 code       // If the previous value is null, no mapping exists.
--------------------------------------------------
Closure_95 hunk 1 code 
        // don't try to declare in the global scope if there's
        // already a symbol there with this name.
--------------------------------------------------
Closure_24 hunk 2 code           // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
--------------------------------------------------
Closure_87 hunk 1 code           // IE has a bug where event handlers behave differently when
          // their return value is used vs. when their return value is in
          // an EXPR_RESULT. It's pretty freaking weird. See:
          // http://code.google.com/p/closure-compiler/issues/detail?id=291
          // We try to detect this case, and not fold EXPR_RESULTs
          // into other expressions.
--------------------------------------------------
Closure_87 hunk 2 code 
            // We only have to worry about methods with an implicit 'this'
            // param, or this doesn't happen.
--------------------------------------------------
Closure_87 hunk 3 code 
--------------------------------------------------
Closure_141 hunk 1 code         // Anonymous functions definitions are not changed by side-effects,
        // and named functions are not part of expressions.
--------------------------------------------------
Mockito_23 hunk 3 code 
--------------------------------------------------
Mockito_23 hunk 7 code 		
--------------------------------------------------
Mockito_25 hunk 6 code 
--------------------------------------------------
Mockito_25 hunk 7 code 
--------------------------------------------------
Mockito_25 hunk 8 code 
--------------------------------------------------
Mockito_25 hunk 9 code 
--------------------------------------------------
Mockito_12 hunk 2 code                 //in case of nested generics we don't go deep
--------------------------------------------------
Mockito_9 hunk 1 code 
--------------------------------------------------
Mockito_33 hunk 1 code         	/* Avoid unnecessary cloning */
--------------------------------------------------
Mockito_13 hunk 2 code                 // this means there is an invocation on a different mock. Re-adding verification mode 
                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
--------------------------------------------------
